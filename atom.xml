<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>longhai&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-13T15:37:41.571Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>龙海</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++11多线程 -【3】传参给线程</title>
    <link href="http://yoursite.com/2018/11/13/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B%20-%E3%80%903%E3%80%91%E4%BC%A0%E5%8F%82%E7%BB%99%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/11/13/C++11多线程 -【3】传参给线程/</id>
    <published>2018-11-13T15:01:49.000Z</published>
    <updated>2018-11-13T15:37:41.571Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://thispointer.com/c11-multithreading-part-3-carefully-pass-arguments-to-threads/" target="_blank" rel="noopener">C++11 Multithreading – Part 3: Carefully Pass Arguments to Threads</a></p></blockquote><p>要将参数传递给线程关联的可调用对象或函数，只需将参数传递给 std::thread 构造函数。</p><p>默认情况下，所有参数都被复制到新线程的内部存储中。</p><h2 id="向-C-11-中的-std-thread-传递简单参数"><a href="#向-C-11-中的-std-thread-传递简单参数" class="headerlink" title="向 C++ 11 中的 std::thread 传递简单参数"></a>向 C++ 11 中的 std::thread 传递简单参数</h2><p>如下是一个简单示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCallback</span><span class="params">(<span class="keyword">int</span> x, <span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Passed Number = "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Passed String = "</span>&lt;&lt;str&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Sample String"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(threadCallback, x, str)</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何不将参数传递给-C-11-中的线程"><a href="#如何不将参数传递给-C-11-中的线程" class="headerlink" title="如何不将参数传递给 C++ 11 中的线程"></a>如何不将参数传递给 C++ 11 中的线程</h2><blockquote><p>译者注：这里的标题感觉和下文的内容不是很符合，“什么情况不能将参数传递给线程”更为合适？</p></blockquote><p>不要将变量的地址从本地堆栈传递给线程的回调函数。因为线程 1 中的局部变量可能超出范围，但是线程 2 仍然试图通过其地址访问它。</p><p>在这种情况下，访问无效地址会导致意外行为。</p><p>请看如下示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newThreadCallback</span><span class="params">(<span class="keyword">int</span> * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside Thread :  "</span><span class="string">" : p = "</span>&lt;&lt;p&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">( <span class="number">1000</span> )</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for( dura );</span><br><span class="line">    *p = <span class="number">19</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startNewThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside Main Thread :  "</span><span class="string">" : i = "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(newThreadCallback,&amp;i)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside Main Thread :  "</span><span class="string">" : i = "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    startNewThread();</span><br><span class="line">    <span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">( <span class="number">2000</span> )</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for( dura );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，将指向堆上内存的指针传递给线程时也要小心。因为在新线程试图访问内存之前，一些线程可能会删除该内存。</p><p>在这种情况下，访问无效地址会导致意外行为。</p><p>请看如下示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newThreadCallback</span><span class="params">(<span class="keyword">int</span> * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside Thread :  "</span><span class="string">" : p = "</span>&lt;&lt;p&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">( <span class="number">1000</span> )</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for( dura );</span><br><span class="line">    *p = <span class="number">19</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startNewThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * p = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside Main Thread :  "</span><span class="string">" : *p = "</span>&lt;&lt;*p&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(newThreadCallback,p)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    startNewThread();</span><br><span class="line">    <span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">( <span class="number">2000</span> )</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for( dura );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何在-C-11-中将引用传递给-std-thread"><a href="#如何在-C-11-中将引用传递给-std-thread" class="headerlink" title="如何在 C++ 11 中将引用传递给 std::thread"></a>如何在 C++ 11 中将引用传递给 std::thread</h2><p>因为参数被复制到新线程堆栈，所以，如果你需要以普通方式传递引用，如下例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCallback</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> &amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp; y = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> &amp;&gt;(x);</span><br><span class="line">    y++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside Thread x = "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"In Main Thread : Before Thread Start x = "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(threadCallback, x)</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"In Main Thread : After Thread Joins x = "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In Main Thread : Before Thread Start x = 9</span><br><span class="line">Inside Thread x = 10</span><br><span class="line">In Main Thread : After Thread Joins x = 9</span><br></pre></td></tr></table></figure><p>即使<code>threadCallback</code>接受引用作为参数，但进行了更改之后，在线程之外也不可见。</p><p>这是因为线程函数<code>threadCallback</code>中的 x 是在新线程堆栈中复制的临时值的引用。</p><p>怎样修复上面的问题？</p><p>使用<code>std::ref()</code>，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCallback</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> &amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp; y = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> &amp;&gt;(x);</span><br><span class="line">    y++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside Thread x = "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"In Main Thread : Before Thread Start x = "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    std::thread threadObj(threadCallback,std::ref(x));</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"In Main Thread : After Thread Joins x = "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In Main Thread : Before Thread Start x = 9</span><br><span class="line">Inside Thread x = 10</span><br><span class="line">In Main Thread : After Thread Joins x = 10</span><br></pre></td></tr></table></figure><h2 id="将指向类成员函数的指针作为线程函数"><a href="#将指向类成员函数的指针作为线程函数" class="headerlink" title="将指向类成员函数的指针作为线程函数"></a>将指向类成员函数的指针作为线程函数</h2><p>将指向成员函数的指针作为回调函数传递，将指向对象的指针作为第二个参数传递。</p><p>看下面的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DummyClass()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    DummyClass(<span class="keyword">const</span> DummyClass &amp; obj)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sampleMemberFunction</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside sampleMemberFunction "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    DummyClass dummyObj;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(&amp;DummyClass::sampleMemberFunction,&amp;dummyObj, x)</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Inside sampleMemberFunction 10</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://thispointer.com/c11-multithreading-part-3-carefully-pass-arguments-to-threads/&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11多线程-【2】线程的join和detach</title>
    <link href="http://yoursite.com/2018/10/28/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E3%80%902%E3%80%91%E7%BA%BF%E7%A8%8B%E7%9A%84join%E5%92%8Cdetach-md/"/>
    <id>http://yoursite.com/2018/10/28/C++11多线程-【2】线程的join和detach-md/</id>
    <published>2018-10-28T11:47:34.000Z</published>
    <updated>2018-10-28T13:40:47.565Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://thispointer.com/c11-multithreading-part-2-joining-and-detaching-threads/" target="_blank" rel="noopener">C++11 Multithreading – Part 2: Joining and Detaching Threads</a></p></blockquote><p>本文介绍线程对象 std::thread 的 joining 和 detaching。</p><h2 id="使用-std-thread-join-进行线程的-joining"><a href="#使用-std-thread-join-进行线程的-joining" class="headerlink" title="使用 std::thread::join() 进行线程的 joining"></a>使用 std::thread::join() 进行线程的 joining</h2><p>一旦一个线程开始之后，另一个线程可以等待此线程结束。</p><p>需要等待的线程可以调用 std::thread 的 join() 函数来实现上述功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">th</span><span class="params">(funcPtr)</span></span>;</span><br><span class="line"><span class="comment">//some code</span></span><br><span class="line">th.join();</span><br></pre></td></tr></table></figure><p>下面看一个简单的例子。</p><p>假设主线程需要启动 10 个工作线程，开始这些线程之后，主线程需要等待这些线程结束。等 joining 所有的线程之后，主程序继续运行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Worker Thread "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is Executing"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threadList;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        threadList.push_back(<span class="built_in">std</span>::thread(WorkerThread()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待所有的工作线程结束，即对每一个 std::thread 对象调用 join() 函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"wait for all the worker thread to finish"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::for_each(threadList.begin(), threadList.end(), <span class="built_in">std</span>::mem_fn(&amp;<span class="built_in">std</span>::thread::join));</span><br><span class="line">    <span class="comment">// 下面这条语句是最后打印的</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Exiting from Main Thread"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-std-thread-detach-进行线程的-detaching"><a href="#使用-std-thread-detach-进行线程的-detaching" class="headerlink" title="使用 std::thread::detach() 进行线程的 detaching"></a>使用 std::thread::detach() 进行线程的 detaching</h2><p>detached 线程也被称为守护/后台进程。对线程进行 detached（翻译成分离？）操作，需要使用对 std::thread 对象调用 std::detach() 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">th</span><span class="params">(funcPtr)</span></span>;</span><br><span class="line">th.detach();</span><br></pre></td></tr></table></figure><h2 id="小心调用线程的-detach-和-join"><a href="#小心调用线程的-detach-和-join" class="headerlink" title="小心调用线程的 detach() 和 join()"></a>小心调用线程的 detach() 和 join()</h2><p><strong>案例1：不要在没有相关执行线程的 std::thread 对象上调用 join() 或 detach()</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::thread threadObj( (WorkerThread()) );</span><br><span class="line">threadObj.join();</span><br><span class="line">threadObj.join(); <span class="comment">// 会导致程序中断</span></span><br></pre></td></tr></table></figure><p>对线程对象调用 join() 函数，则当这个 join() 返回时，std::thread 对象就没有了与之相关联的线程。对这样的 std::thread 对象再次进行 join() 函数调用时，就会导致程序中断。</p><p>同理，调用 detach() 一样会使得 std::thread 对象不与其他任何的线程关联。在这种情况下，再次调用 detach() 会中断程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::thread threadObj( (WorkerThread()) );</span><br><span class="line">threadObj.detach();</span><br><span class="line">threadObj.detach(); <span class="comment">// 会导致程序中断</span></span><br></pre></td></tr></table></figure><p>因此，在调用 join() 或者 detach() 之前，我们每次都应该检查线程是否是 join-able 的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">std::thread threadObj( (WorkerThread()) );</span><br><span class="line"><span class="keyword">if</span>(threadObj.joinable())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Detaching Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj.detach();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(threadObj.joinable())    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Detaching Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj.detach();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::thread threadObj2( (WorkerThread()) );</span><br><span class="line"><span class="keyword">if</span>(threadObj2.joinable())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Joining Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj2.join();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(threadObj2.joinable())    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Joining Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例2：永远不要忘记在有关联的执行线程的 std::thread 对象上调用 join 或者 detach</strong></p><p>假如对一个有关联执行线程的 std::thread 对象并没有调用 join() 也没有调用 thread()，则在对象的析构的过程中会中断程序。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Worker Thread "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::thread threadObj((WorkerThread()));</span><br><span class="line">    <span class="comment">// 程序会中断，因为既没有调用 join() 也没有调用 detach()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样在异常情况下，我们也不能忘记调用 join() 或者 detach()。</p><p>为了防止这种情况，我们应该使用 ESOURCE ACQUISITION IS INITIALIZATION (RAII)。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadRAII</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::thread &amp;m_thread;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ThreadRAII(<span class="built_in">std</span>::thread &amp;threadObj) : m_thread(threadObj) &#123;&#125;</span><br><span class="line">    ~ThreadRAII() &#123;</span><br><span class="line">        <span class="comment">// 假如 joinable 则调用 detach</span></span><br><span class="line">        <span class="keyword">if</span> (m_thread.joinable()) &#123;</span><br><span class="line">            m_thread.detach();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread_function executing"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注释掉这行，程序会 crash</span></span><br><span class="line">    <span class="function">ThreadRAII <span class="title">wrapperObj</span><span class="params">(threadObj)</span></span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://thispointer.com/c11-multithreading-part-2-joining-and-detaching-threads/&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11多线程-【1】创建线程的三种方式</title>
    <link href="http://yoursite.com/2018/10/17/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E3%80%901%E3%80%91%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/17/C++11多线程-【1】创建线程的三种方式/</id>
    <published>2018-10-17T15:01:00.000Z</published>
    <updated>2018-10-28T13:40:40.597Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://thispointer.com/c-11-multithreading-part-1-three-different-ways-to-create-threads/" target="_blank" rel="noopener">C++11 Multithreading – Part 1 : Three Different ways to Create Threads</a></p></blockquote><p>本篇介绍如何在 C++11 中使用 std::thread 来创建线程。</p><h2 id="C-11-线程库介绍"><a href="#C-11-线程库介绍" class="headerlink" title="C++11 线程库介绍"></a>C++11 线程库介绍</h2><p>传统的C++只支持单线程编程。新的 C++ 标准 (即 C++11 或 C++0x) 于 2011 年发布。 C++11 中引入了一个新的线程库。</p><p><strong>编译器要求：</strong>  </p><p><strong>Linux:</strong> gcc 4.8.1 （完整的并发支持）<br><strong>Windows:</strong> Visual Studio 2012 and MingW</p><p><strong>Linux 下如何编译：</strong> <code>g++ –std=c++11 sample.cpp -lpthread</code></p><h2 id="C-11-线程创建"><a href="#C-11-线程创建" class="headerlink" title="C++11 线程创建"></a>C++11 线程创建</h2><p>每一个 C++11 程序都包含一个主线程即 main() 函数。 在 C++11 中我们可以通过创建 std::thread 对象来创建新的线程。</p><p>每个 std::thread 对象都可以与一个线程相关联。 </p><p>需要引用的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="std-thread的构造函数中接受什么参数？"><a href="#std-thread的构造函数中接受什么参数？" class="headerlink" title="std::thread的构造函数中接受什么参数？"></a>std::thread的构造函数中接受什么参数？</h3><p>我们可以给 std::thread 对象添加函数，这个回调函数将在这个新线程启动时执行。这些回调可以是：</p><p>1.) 函数指针<br>2.) 函数对象<br>3.) Lambda 函数</p><p>创建 thread 对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">thObj</span><span class="params">(&lt;CALLBACK&gt;)</span></span>;</span><br></pre></td></tr></table></figure><p>新线程将在创建新对象后立即启动，并将并行地执行（当参数）传递给线程的回调函数。 </p><p>此外，任何线程都可以通过调用某线程对象上的 join( ) 函数来等待此线程退出。</p><p>让我们看一个例子，主线程将创建另外一个线程。创建这个新线程后，主线程会在控制台上打印一些数据，然后等待新创建的线程退出。 </p><p>下面我们使用三种不同回调机制来实现上面的内容。</p><h3 id="使用函数指针创建线程"><a href="#使用函数指针创建线程" class="headerlink" title="使用函数指针创建线程"></a>使用函数指针创建线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread function Executing"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Display From MainThread"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj.join();    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Exit of Main function"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用函数对象创建线程"><a href="#使用函数对象创建线程" class="headerlink" title="使用函数对象创建线程"></a><strong>使用函数对象创建线程</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayThread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Display Thread Executing"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread threadObj( (DisplayThread()) );</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Display From Main Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Waiting For Thread to complete"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Exiting from Main Thread"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Lambda-函数创建线程"><a href="#使用-Lambda-函数创建线程" class="headerlink" title="使用 Lambda 函数创建线程"></a><strong>使用 Lambda 函数创建线程</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span></span></span><br><span class="line">                std::cout&lt;&lt;"Display Thread Executing"&lt;&lt;std::endl;</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Display From Main Thread"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Exiting from Main Thread"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何区分线程"><a href="#如何区分线程" class="headerlink" title="如何区分线程"></a>如何区分线程</h2><p>每个 std::thread 对象都有一个 ID，使用下面的函数可以获取：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::thread::get_id()</span><br></pre></td></tr></table></figure><p>获取当前线程的 ID：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::this_thread::get_id()</span><br></pre></td></tr></table></figure><p>如果 std::thread 对象没有和任何对象关联，则 get_id() 函数会返回默认构造的 std::thread::id 对象，即“非线程”。</p><p>std::thread::id 是一个对象，它也可以在控制台上进行比较和打印。让我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside Thread :: ID  = "</span>&lt;&lt;<span class="built_in">std</span>::this_thread::get_id()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj1</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj2</span><span class="params">(thread_function)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(threadObj1.get_id() != threadObj2.get_id())</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Both Threads have different IDs"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"From Main Thread :: ID of Thread 1 = "</span>&lt;&lt;threadObj1.get_id()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"From Main Thread :: ID of Thread 2 = "</span>&lt;&lt;threadObj2.get_id()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line"> </span><br><span class="line">    threadObj1.join();    </span><br><span class="line">    threadObj2.join();    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://thispointer.com/c-11-multithreading-part-1-three-different-ways-to-create-threads/&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++(2)--尽量用编译器取代预处理器</title>
    <link href="http://yoursite.com/2018/09/16/Effective-C-2/"/>
    <id>http://yoursite.com/2018/09/16/Effective-C-2/</id>
    <published>2018-09-16T13:37:36.000Z</published>
    <updated>2018-09-16T13:51:18.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基本摘抄自《Effective C++》 item2</p></blockquote><blockquote><p>尽量以 const， enum，inline 替换 #define</p></blockquote><h2 id="1-以常量替换-define"><a href="#1-以常量替换-define" class="headerlink" title="1 以常量替换 #define"></a>1 以常量替换 #define</h2><h3 id="1-1-定义常量"><a href="#1-1-定义常量" class="headerlink" title="1.1 定义常量"></a>1.1 定义常量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure><p>局限性：</p><ul><li>不会被编译器看见，或者在编译器开始处理源码之前被编译器移走</li><li>运用此常量获得编译错误信息时，可能带来困惑，因为错误信息会提到 1.653 而不是 ASPECT_RATIO</li><li>在记号式调试器中，由于使用名称没有进入记号表导致难以追踪</li></ul><p>解决：</p><blockquote><p>用常量替换宏</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span>;</span><br></pre></td></tr></table></figure><ul><li>作为语言常量，AspectRatio 肯定会被编译器看到，当然就会进入到记号表内</li><li>对浮点常量而言，使用常量可能比使用 #define 导致较小量的码，因为预处理“盲目地将名称 ASPECT_RATIO 替换为 1.653”可能导致目标码出现多份 1.653。</li></ul><p>下面说说两种特殊情况。</p><h3 id="1-2-定义常量指针"><a href="#1-2-定义常量指针" class="headerlink" title="1.2 定义常量指针"></a>1.2 定义常量指针</h3><p>由于常量定义式通常被放在头文件内（以便被不同的源码含入），因此有必要将指针（而不只是指针所指之物）声明为 const。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> authorName = <span class="string">"Longhai"</span>;</span><br></pre></td></tr></table></figure><p>详细见下一篇文章。<strong>string 对象通常比他的前辈 char *-base 更合适：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> authorName = <span class="string">"Longhai"</span>;</span><br></pre></td></tr></table></figure><h3 id="1-3-定义class专属常量"><a href="#1-3-定义class专属常量" class="headerlink" title="1.3 定义class专属常量"></a>1.3 定义class专属常量</h3><p>为了将常量的作用域（scope）限制于 class 内，必须让它成为 class 的一个成员（member）；而为确保此常量至多只有一份实体，必须让它成为一个 static 成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class GamePlayer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>;<span class="comment">//常量声明式</span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];<span class="comment">//使用该常量</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的是<code>NumTurns</code>的声明式而非定义式。</p><p>对于支持类内初始化的 C++ 编译器，这段代码可以编译通过。</p><p>但是较老的 C++ 编译器，可能不支持类内初始化，这样我们的静态常量，必须要在类外初始化。如下（在实现文件而非头文件中定义）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns;<span class="comment">//NumTurns的定义</span></span><br></pre></td></tr></table></figure><p>由于 class 常量已在声明时获得初值，因此定义时不可以再设初值。</p><p>更老的编译器可能不支持 static 成员在其声明式上获得初值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class GamePlayer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>;<span class="comment">//常量声明式</span></span><br><span class="line">    <span class="meta"># int scores[NumTurns];<span class="comment">//使用该常量</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns = <span class="number">5</span>;<span class="comment">//NumTurns的定义</span></span><br></pre></td></tr></table></figure><p>但是当在 class 编译期间需要一个 class 常量值，例如数组声明式（编译器坚持必须在编译期间知道数组的大小）。此时可以使用<code>the enum hack</code>方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class GamePlayer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;;<span class="comment">//令 NumTurns 成为 5 的一个记号名称</span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];<span class="comment">//使用该常量</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>enum hack</code>的行为某些方面比较像 #define 而不是 const，譬如取一个 const 的地址是合法的，但取一个 enum 的地址是不合法的，而取一个 #define 的地址通常（？为什么是通常）也不合法。</li><li>使用<code>enum hack</code>和 #define 一样不会导致 “不必要的内存分配”。 </li><li><code>enum hack</code>是模板元编程的一项基本技术，大量的代码在使用它。当你看到它时，你要认识它。 </li></ul><blockquote><p> 除非你处理的是主要具有历史意义的编译器(即1995年之前编写的编译器)，否则你不应该使用<code>enum hack</code>。尽管如此，知道它是什么样子还是值得的，因为在那些早期简单的时代，代码中遇到它并不少见。 </p></blockquote><h2 id="2-实现宏"><a href="#2-实现宏" class="headerlink" title="2 实现宏"></a>2 实现宏</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure><ul><li><p>无论何时，<strong>必须记住为宏中的所有实参加上小括号</strong></p></li><li><p>即使为所有实参加上小括号，也有可能有问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line">CALL_WITH_MAX(++a, b);<span class="comment">//a被累加2次</span></span><br><span class="line">CALL_WITH_MAX(++a, b+<span class="number">10</span>)<span class="comment">//a被累加1次</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>template inline 函数 – 同时获取宏带来的效率以及一般函数的所有可预料行为和类型安全性。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 由于我们不知道T是什么，所以采用 pass by reference-to-const. */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><ul><li><p>有了 consts、enums 和 inlines，我们对预处理器（<strong>尤其是 #define</strong>）的需求降低了，但并非完全消除。</p></li><li><p><code>#include</code>仍然是必需品，而<code>#ifdef / #ifndef</code>也继续扮演控制编译的重要角色。</p></li><li><p>对于单纯变量，最好以 const 对象或 enums 替换 #defines<br>对于形式函数的宏（macros），最好改用 inline 函数替换 #defines」</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文基本摘抄自《Effective C++》 item2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;尽量以 const， enum，inline 替换 #define&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++(1)--视C++为一个语言联邦</title>
    <link href="http://yoursite.com/2018/09/16/Effective-C-1/"/>
    <id>http://yoursite.com/2018/09/16/Effective-C-1/</id>
    <published>2018-09-16T11:36:29.000Z</published>
    <updated>2018-09-16T13:51:28.763Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基本摘抄自《Effective C++》 item1</p></blockquote><blockquote><p>将 C++ 视为一个由相关语言组成的联邦而非单一语言。<br>在其某个次语言（sublanguage）中，各种守则与通例都倾向简单、直观易懂、并且容易记住。<br>C++ <strong>4</strong>个次语言：</p></blockquote><ul><li><code>C</code>。说到底 C++ 还是以 C 为基础。许多时候 C++ 对于问题的解法其实不过就是较高级的 C 解法。</li><li><code>Object-Oriented C++</code>。即<code>C with class</code>所诉求的，对象、封装、集成、多态、virtual 函数等。</li><li><code>Template C++</code>。泛型编程部分（笔者注：这个就是自己不曾接触的部分）。</li><li><code>STL</code>。标准模板库，包含 4 个组件：算法、容器、迭代器以及函数。</li></ul><blockquote><p>从某个次语言切换到另一个，导致高效编程守则可能要求改变策略。<br>【例】<em>指针（值）还是引用传递问题？</em></p></blockquote><ul><li>内置类型（C-like）：<code>pass-by-value</code>通常比<code>pass-by-reference</code>高效</li><li>对象类型（<code>Object-Oriented C++</code>）：由于用户自定义构造函数和析构函数的存在，<code>pass-by-reference-to-const</code>往往更好</li><li><code>Template C++</code>：用引用，因为这个时候可能都不知道所处理的对象的类型。</li><li><code>STL</code>：迭代器和函数对象都是在 C 指针之上塑造出来的，所以对 STL 的迭代器和函数对象来说，旧式的 C <code>pass-by-value</code>守则再次适用。</li></ul><blockquote><p>作为从 C 语言转到 C++ 来说，这个次语言的概念确实对于理解整个 C++ 有一定的指导作用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文基本摘抄自《Effective C++》 item1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;将 C++ 视为一个由相关语言组成的联邦而非单一语言。&lt;br&gt;在其某个次语言（sublanguage）中，各种守则与通例都
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《参与感》小结</title>
    <link href="http://yoursite.com/2018/09/05/%E3%80%8A%E5%8F%82%E4%B8%8E%E6%84%9F%E3%80%8B%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2018/09/05/《参与感》小结/</id>
    <published>2018-09-04T23:53:54.000Z</published>
    <updated>2018-09-05T15:57:19.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学"><a href="#学" class="headerlink" title="学"></a>学</h2><p>书中主要内容及观点用思维导图概括如下：</p><p><img src="http://oi435vw1u.bkt.clouddn.com/%E5%8F%82%E4%B8%8E%E6%84%9F.png" alt="参与感"></p><h2 id="思"><a href="#思" class="headerlink" title="思"></a>思</h2><h3 id="小米的互联网思维"><a href="#小米的互联网思维" class="headerlink" title="小米的互联网思维"></a>小米的互联网思维</h3><ol><li>以用户为核心<ul><li>海底捞之所以火爆，是因为他们的服务确实好。单独的大厅用于等餐位（环境较好）、叠千纸鹤减免的小活动（客户可以从中获得小利益）、免费大麦茶及瓜子（打发无聊的等位时光）。【个人思考：在现今每个人都用手机打发无聊时光的时代，除了上述好的服务之外，等位的时候是否应该提供一个较好的“手机环境”，譬如快速的 WiFi，方便的充电等；还是秉承一个“去手机”理念，想法设法让大家接受吃饭的目的，是面对面社交？】</li></ul></li><li>口碑为王<ul><li>咨询了身边朋友唯一的小米粉，他成为小米忠实粉中的一员最主要的原因还是当年高性价比的爆品，再以书中多次提到的好用的 MIUI 系统加持。</li><li>《西虹市首富》只能算是一部及格作品，票房高有很大一个原因是开心麻花你的前面几部作品积攒的口碑，使观众习惯性的觉得会物超所值（当然作品不会太差）。与之对比的《我不是药神》，没有前作的口碑加成，只能纯粹靠观众的口口相传。这里做一个假设，假如原班人马（甚至是非原班人马）出《我不是药神2》，一开始的排片和上座率肯定惊人，假如作品一如既往的好，票房可期。</li></ul></li></ol><h3 id="小米崇尚的“参与感”到底是什么？"><a href="#小米崇尚的“参与感”到底是什么？" class="headerlink" title="小米崇尚的“参与感”到底是什么？"></a>小米崇尚的“参与感”到底是什么？</h3><ol><li><p>做爆品</p><ul><li>2018 年在智能手机市场整体下滑的情况下，华为手机依旧保持着不错的增长率，究其原因，有持续出爆款的因素。P20 的莱卡三摄、“吓死人的技术” GPU turbo、搭载麒麟 980（毕竟自研直逼世界一流水平）的新机magic 2即将上市，前两者是超乎客户预期的“爆品”，后者在华为手机已有口碑的情况下，可以预见也将是新一轮爆款的可能性非常大。</li></ul></li><li><p>互动方式的设计</p><p>互动方式必须有的原则：简单、收益、有趣、真实。</p><p>其中我思考比较多的是收益和真实。</p><ul><li>收益。其实无须多言，必须做到在客户得到优惠的前提下，自己也能从中获益。客户没有得到优惠，或者“性价比”，无法形成口碑；自己没有获益，等于自掘坟墓，无法长久。</li><li>真实。信任是一个很难量化的指标，而真实是获得信任的基础。我想所有人都比较喜欢和真诚实在的人打交道，至少不会因为说错一句话就会被人暗自“惦记”。马爸爸和阿里的六脉神剑，诚信乃其中一脉，支付宝的成功，最基础的应该归功于阿里建造了一套信用体系。也就是我相信，我付了钱，一定可以拿到我买的东西，虽然我对卖家的信息一无所知，并不知道对方是男是女，是善是恶。</li></ul></li></ol><h2 id="用"><a href="#用" class="headerlink" title="用"></a>用</h2><blockquote><p>【学为用】我们如何用互联网思维经营一家小区内普通的生活超市？</p></blockquote><p>我想，我们把经营超市当做一个产品，同样适用互联网思维。可以从下面几点来做，顺便指出其中使用的书中提到的背后逻辑。</p><ol><li><p>【用户体验】</p><p>对于超市来说，所有产品都是一些生活中需要的小物品，所以首先从产品的角度，所有超市的起点都是差不多的。那么使用基于“保证好用、努力好看”的原则，应该重点关注的就应该是“好看”的方向：</p><ul><li>必须保证超市内整体环境的<strong>整洁</strong>，给人一个好的第一印象。给顾客好印象需要日积月累的好感，但是坏印象只需要一次失望。</li><li>保证<strong>所有</strong>商品不积灰。同上的一个原理，也结合我们平常的购物经验，假如一家超市的商品上有积灰，会给人一种商品滞销、担心变质的心理暗示，这种情况下别说我们想要塑造的口碑，连这个客户可能都会永久的失去，毕竟和你竞争的同行很多，对于客户来说也就多走几步的关系。请关注重点词汇是所有，要做到这个真的需要费一些心力。</li><li>多站在<strong>顾客的角度</strong>思考问题。举一个简单的例子，假设超市内4G网络并不好，在现在大家平常支付都是掏出手机扫一扫的场景下，就非常有必要将WIFI及密码在比较醒目的点公示，并告诉大家4G网络不好，请提前连接WiFi。</li></ul></li><li><p>【口碑及强用户关系】</p><p>对于商品同质化严重的超市来说，要营造口碑是一个比较困难的事情。可以从如下几个角度切入：</p><ul><li>门店定期推出优惠活动，牺牲一点小利润培养用户的黏性和习惯。要相信，习惯一旦养成就会很难改变。</li><li>一般只有比较大型一点的超市才会设置会员制度，条件允许的情况下可以考虑会员系统。会员系统的作用就是要达到“用完即走”之后“想用即来”的效果。</li><li>对一个固定的商品，尽量使它成为附近人们购买的首选（即爆款），及时这款产品不产生利益。只有这样才能起到口口相传的口碑效应。</li><li>建立微信群，群内不定期发布优惠活动、团购活动等，增加用户活跃度。</li><li>微信群及门店的优惠活动都需要征询顾客的意见，让用户参与到优惠活动的制定中来（参与感），让用户得到切身需要的“性价比”。</li><li>重视“鲸鱼”客户，简单来说就是大客户。遇到一次购买比较多的商品（主要是烟酒）的顾客，尽量留下联系方式（最好是微信，用户关系最强），尽量进行更便利的服务，譬如送货上门等。</li></ul></li></ol><p>综合起来也有接近10来点值得注意的地方。想到这个案例是因为姐姐开了这样的一家小超市，希望后续可以策划更加详细的方案，帮助提升她的销售量，那就真的是学以致用了。</p><h2 id="感"><a href="#感" class="headerlink" title="感"></a>感</h2><p>《参与感》一书，虽然只听了一个大概系统内容，但是觉得还是可以深读一下。</p><p>互联网的口碑思维，在现在的商业环境应该说放到任何一个产品都是适用的，我们都应该学习并思考，假如有机会去实践，那就更加求之不得了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学&quot;&gt;&lt;a href=&quot;#学&quot; class=&quot;headerlink&quot; title=&quot;学&quot;&gt;&lt;/a&gt;学&lt;/h2&gt;&lt;p&gt;书中主要内容及观点用思维导图概括如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oi435vw1u.bkt.clouddn.com/%E5%
      
    
    </summary>
    
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>每天5分钟学MySQL内核(3) -- MySQL redo log 简介</title>
    <link href="http://yoursite.com/2018/09/01/%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E5%AD%A6MySQL%E5%86%85%E6%A0%B83/"/>
    <id>http://yoursite.com/2018/09/01/每天5分钟学MySQL内核3/</id>
    <published>2018-09-01T08:49:53.000Z</published>
    <updated>2018-09-01T09:12:22.248Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文采用创作共用署名2.5中国大陆版许可证（Creative Commons Attribution 2.5 China Mainland License）授权。</p></blockquote><p><a href="http://mysql.taobao.org/monthly/2017/09/07/" target="_blank" rel="noopener">[1] MySQL · 源码分析 · Innodb 引擎Redo日志存储格式简介</a></p><p><a href="https://blog.csdn.net/qiuyepiaoling/article/details/7838951" target="_blank" rel="noopener">[2] InnoDB存储引擎Log</a></p><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>任何对 Innodb 表的变动, redo log 都要记录对数据的修改，redo 日志就是记录要修改后的数据。redo 日志是保证事务一致性非常重要的手段，同时也可以使在 bufferpool 修改的数据不需要在事务提交时立刻写到磁盘上减少数据的 IO 从而提高整个系统的性能。这样的技术推迟了 bufferpool 页面的刷新，从而提升了数据库的吞吐，有效的降低了访问时延。带来的问题是额外的写 redo log 操作的开销。而为了保证数据的一致性，都要求 WAL（Write Ahead Logging）。而 redo 日志也不是直接写入文件，而是先写入 redo log buffer，而是批量写入日志。当需要将日志刷新到磁盘时（如事务提交），将许多日志一起写入磁盘。</p><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h2><ul><li>和 undo log 相反，redo log 记录的是<strong>新数据</strong>的备份。</li><li>在事务提交前，只要将 redo log 持久化即可，不需要将数据持久化。</li><li>当系统崩溃时，虽然数据没有持久化，但是 redo log 已经持久化。</li><li>系统可以根据 redo log 的内容，将所有数据恢复到最新的状态。 </li></ul><h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h2><p><strong>undo + redo 事务的简化过程</strong></p><p><img src="http://oi435vw1u.bkt.clouddn.com/undo+redo%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E6%8C%81%E4%B9%85%E6%80%A7%E7%A4%BA%E4%BE%8B.jpg" alt="undo+redo保证原子性与持久性示例"></p><ul><li>为了保证持久性，必须在事务提交前将 redo log 持久化</li><li>数据不需要在事务提交前写入磁盘，而是缓存在内存中</li><li>redo log 保证事务的持久性</li><li>undo log 保证事务的原子性</li><li>有一个隐含的特点，数据必须要晚于 redo log 写入持久存储</li></ul><h2 id="4-性能"><a href="#4-性能" class="headerlink" title="4. 性能"></a>4. 性能</h2><blockquote><p>undo + redo 的设计主要考虑的是提升 IO 性能。</p><p>虽说通过缓存数据，减少了写数据的 IO，但是却引入了新的IO，即写 redo log 的 IO。</p><p>如果 redo log 的 IO 性能不好，就不能起到提高性能的目的。</p></blockquote><p>为了保证 redo log 能够有比较好的 IO 性能，InnoDB 的 redo log 的设计有以下几个特点：</p><ul><li>尽量持 redo log 存储在一段连续的空间上。因此在系统第一次启动时就会将日志文件的空间完全分配，以顺序追加的方式记录 redo log，通过顺序 IO 来改善性能。</li><li>批量写入日志。日志并不是直接写入文件，而是先写入 redo log buffer。当需要将日志刷新到磁盘时 （如事务提交），将许多日志一起写入磁盘。</li><li>并发的事务共享 redo log 的存储空间，它们的 redo log 按语句的执行顺序，依次交替的记录在一起，以减少日志占用的空间。例如，redo log 中的记录内容可能是这样的：<ul><li>记录1:  &lt;trx1, insert …&gt;</li><li>记录2:  &lt;trx2, update …&gt;</li><li>记录3:  &lt;trx1, delete …&gt;</li><li>记录4:  &lt;trx3, update …&gt;</li><li>记录5:  &lt;trx2, insert …&gt;</li></ul></li><li>基于上一点，当一个事务将 redo log 写入磁盘时，也会将其他未提交的事务的日志写入磁盘。</li><li>redo log 上只进行顺序追加的操作，当一个事务需要回滚时，它的 redo log 记录也不会从 redo log 中删除掉。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文采用创作共用署名2.5中国大陆版许可证（Creative Commons Attribution 2.5 China Mainland License）授权。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://mysql
      
    
    </summary>
    
    
      <category term="MySQL内核" scheme="http://yoursite.com/tags/MySQL%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>每天5分钟学MySQL内核(2) -- undo log与AD</title>
    <link href="http://yoursite.com/2018/08/31/%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E5%AD%A6MySQL%E5%86%85%E6%A0%B82/"/>
    <id>http://yoursite.com/2018/08/31/每天5分钟学MySQL内核2/</id>
    <published>2018-08-30T22:54:10.000Z</published>
    <updated>2018-09-01T08:55:54.715Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文采用创作共用署名2.5中国大陆版许可证（Creative Commons Attribution 2.5 China Mainland License）授权。</p></blockquote><p><a href="https://blog.csdn.net/qiuyepiaoling/article/details/7838951" target="_blank" rel="noopener">[1] InnoDB存储引擎Log</a></p><h2 id="原子性与-undo-log"><a href="#原子性与-undo-log" class="headerlink" title="原子性与 undo log"></a>原子性与 undo log</h2><p>回顾事务的原子性：</p><blockquote><p> 事务中的所有操作，要么全部完成，要么不做任何操作。如果在执行的过程中出现了错误，要回滚（rollback）到事务开始前的状态，就像这个事务从来没有执行过。</p></blockquote><p>在 MySQL 中，使用 undo log 来实现事务的原子性（undo log 还用于实现多版本并发控制[ MVCC ]）。</p><h3 id="undo-简要原理"><a href="#undo-简要原理" class="headerlink" title="undo 简要原理"></a>undo 简要原理</h3><p>为了满足原子性，在操作任何数据之前，首先将数据备份到一个地方（即 undo log），然后进行数据的修改。如果出现了错误或者用户执行了 rollback 语句，数据库可以利用 undo log 中的备份数据恢复到事务开始之前的状态。</p><h2 id="一致性与-undo-log"><a href="#一致性与-undo-log" class="headerlink" title="一致性与 undo log"></a>一致性与 undo log</h2><p>undo log 可以用来辅助完成事务的一致性。</p><blockquote><p><strong>一致性：</strong>事务一旦完成，该事务对数据库所做的所有修改都会持久的保存到数据库中。为了保证持久性，数据库   系统会将修改后的数据完全的记录到持久的存储上。 </p></blockquote><p><strong>用 undo Log 实现原子性和持久化的事务的简化过程</strong></p><p>假设有A、B两个数据，值分别为1，2。</p><p><img src="http://oi435vw1u.bkt.clouddn.com/undo%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E6%8C%81%E4%B9%85%E6%80%A7%E7%A4%BA%E4%BE%8B.jpg" alt="undo保证原子性与持久性示例"></p><p>这里有一个隐含的前提条件：数据都是先读到内存中，然后修改内存中的数据，最后将数据写回磁盘。</p><p>之所以能同时保证原子性和持久化，是因为以下特点:</p><p>A. 更新数据前记录 undo log。</p><p>B. 为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。</p><p>C. Undo log 必须先于数据持久化到磁盘。如果在 G, H 之间系统崩溃，undo log 是完整的，可以用来回滚事务。</p><p>D. 如果在 A-F 之间系统崩溃，因为数据没有持久化到磁盘，所以磁盘上的数据还是保持在事务开始前的状态。</p><p><strong>缺陷：</strong> 每个事务提交前将数据和 undo Log 写入磁盘，这样会导致大量的磁盘 IO，因此性能很低。如果能够将数据缓存一段时间，就能减少 IO 提高性能，但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即 Redo Log。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文采用创作共用署名2.5中国大陆版许可证（Creative Commons Attribution 2.5 China Mainland License）授权。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog
      
    
    </summary>
    
    
      <category term="MySQL内核" scheme="http://yoursite.com/tags/MySQL%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>每天5分钟学MySQL内核(1) -- ACID简介</title>
    <link href="http://yoursite.com/2018/08/26/%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E5%AD%A6MySQL%E5%86%85%E6%A0%B81/"/>
    <id>http://yoursite.com/2018/08/26/每天5分钟学MySQL内核1/</id>
    <published>2018-08-26T14:49:31.000Z</published>
    <updated>2018-08-30T23:04:33.110Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文采用创作共用署名2.5中国大陆版许可证（Creative Commons Attribution 2.5 China Mainland License）授权。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先，我们从数据库的 ACID 说起。</p><ul><li><p>原子性(Atomicity)</p><p>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。</p></li><li><p>一致性(Consistency)</p><p>一致性是指数据处于一种语义上的有意义且正确的状态。</p><p>一致性是对数据可见性的约束，保证在一个事务中的多次操作的数据中间状态对其他事务不可见的。</p><p>因为这些中间状态，是一个过渡状态，与事务的开始状态和事务的结束状态是不一致的。</p></li><li><p>隔离性(Isolation)</p><p>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</p></li><li><p>持久性(Durability)</p><p>指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。</p><p>即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</p></li></ul><p><strong>特性之间的关联</strong></p><ul><li>原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态。</li><li>在未提交读的隔离级别下，会造成脏读，这就是因为一个事务读到了另一个事务操作内部的数据。ACID中是的一致性描述的是一个最理想的事务应该怎样的，是一个强一致性状态，如果要做到这点，需要使用排它锁把事务排成一队，即 Serializable 的隔离级别，这样性能就大大降低了。现实是骨感的，所以使用隔离性的不同隔离级别来破坏一致性，以获取更好的性能。</li><li>最终一致 ~= 读未提交</li></ul><blockquote><p>事务可以不同程度的一致性：</p><ul><li>强一致性：读操作可以立即读到提交的更新操作。</li><li>弱一致性：提交的更新操作，不一定立即会被读操作读到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。</li><li>最终一致性：是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样的值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等。     </li></ul><p>其他一致性变体还有：</p><ul><li>单调一致性：如果一个进程已经读到一个值，那么后续不会读到更早的值。</li><li>会话一致性：保证客户端和服务器交互的会话过程中，读操作可以读到更新操作后的最新值。</li></ul></blockquote><p><a href="https://zh.wikipedia.org/zh-hans/ACID" target="_blank" rel="noopener">数据库ACID-维基</a></p><p><a href="http://geyifan.cn/2016/07/17/talk-about-transaction/" target="_blank" rel="noopener">一致性理解-博客</a></p><p><a href="https://www.zhihu.com/question/31346392" target="_blank" rel="noopener">一致性理解-知乎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文采用创作共用署名2.5中国大陆版许可证（Creative Commons Attribution 2.5 China Mainland License）授权。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言
      
    
    </summary>
    
    
      <category term="MySQL内核" scheme="http://yoursite.com/tags/MySQL%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>SpaceVim使用</title>
    <link href="http://yoursite.com/2018/08/08/SpaceVim%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/08/SpaceVim使用/</id>
    <published>2018-08-08T15:39:28.000Z</published>
    <updated>2018-08-26T03:43:20.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpaceVim简介"><a href="#SpaceVim简介" class="headerlink" title="SpaceVim简介"></a>SpaceVim简介</h1><blockquote><p>SpaceVim 是一个社区驱动的模块化 Vim IDE，以模块(layers)的方式组织管理插件以及相关配置， 为不同的语言开发量身定制了相关的开发模块，该模块提供代码自动补全， 语法检查、格式化、调试、REPL 等特性。用户仅需载入相关语言的模块即可得到一个开箱即用的Vim-IDE。</p><p>灵感来自于 Emacs 界首选配置 Spacemacs。</p></blockquote><h1 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在安装 SpaceVim 之前，确保已安装 <code>git</code> 和 <code>curl，</code>这两个工具用来 下载插件以及字体。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sLf https://spacevim.org/cn/install.sh | bash</span><br></pre></td></tr></table></figure><p>安装结束后，初次打开 <code>vim</code> 或者 <code>neovim</code> 时， SpaceVim 会<strong>自动</strong>下载并安装插件。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>SpaceVim 的默认配置文件为 <code>~/.SpaceVim.d/init.toml</code>，下面为一个简单的配置示例。 如果需要查阅更多 SpaceVim 配置相关的信息，请阅读 SpaceVim 用户文档。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个基础的 SpaceVim 配置示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有的 SpaceVim 选项都列在 [option] 之下</span></span><br><span class="line"><span class="section">[options]</span></span><br><span class="line">    <span class="comment"># 设置 SpaceVim 主题及背景，默认的主题是 gruvbox，如果你需要使用更</span></span><br><span class="line">    <span class="comment"># 多的主题，你可以载入 colorscheme 模块</span></span><br><span class="line">    colorscheme = "gruvbox"</span><br><span class="line">    <span class="comment"># 背景可以取值 "dark" 和 "light"</span></span><br><span class="line">    colorscheme_bg = "dark"</span><br><span class="line">    <span class="comment"># 启用/禁用终端真色，在目前大多数终端下都是支持真色的，当然也有</span></span><br><span class="line">    <span class="comment"># 一小部分终端不支持真色，如果你的 SpaceVim 颜色看上去比较怪异</span></span><br><span class="line">    <span class="comment"># 可以禁用终端真色，将下面的值设为 false</span></span><br><span class="line">    enable_guicolors = true</span><br><span class="line">    <span class="comment"># 设置状态栏上分割符号形状，如果字体安装失败，可以将值设为 "nil" 以</span></span><br><span class="line">    <span class="comment"># 禁用分割符号，默认为箭头 "arrow"</span></span><br><span class="line">    statusline_separator = "nil"</span><br><span class="line">    statusline_separator = "bar"</span><br><span class="line">    <span class="comment"># 设置顶部标签列表序号类型，有以下五种类型，分别是 0 - 4</span></span><br><span class="line">    <span class="comment"># 0: 1 ➛ ➊ </span></span><br><span class="line">    <span class="comment"># 1: 1 ➛ ➀</span></span><br><span class="line">    <span class="comment"># 2: 1 ➛ ⓵</span></span><br><span class="line">    <span class="comment"># 3: 1 ➛ ¹</span></span><br><span class="line">    <span class="comment"># 4: 1 ➛ 1</span></span><br><span class="line">    buffer_index_type = 4</span><br><span class="line">    <span class="comment"># 显示/隐藏顶部标签栏上文件类型图标，这一图标需要安装 nerd fonts，</span></span><br><span class="line">    <span class="comment"># 如果未能成功安装这一字体，可以隐藏图标</span></span><br><span class="line">    enable_tabline_filetype_icon = true</span><br><span class="line">    <span class="comment"># 是否在状态栏上显示当前模式，默认情况下，不显示 Normal/Insert 等</span></span><br><span class="line">    <span class="comment"># 字样，只以颜色区分当前模式</span></span><br><span class="line">    enable_statusline_display_mode = false</span><br><span class="line"></span><br><span class="line"><span class="comment"># SpaceVim 模块设置，主要包括启用/禁用模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用 autocomplete 模块, 启用模块时，可以列出一些模块选项，并赋值，</span></span><br><span class="line"><span class="comment"># 关于模块的选项，请阅读各个模块的文档</span></span><br><span class="line"><span class="section">[[layers]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"autocomplete"</span></span><br><span class="line"><span class="attr">auto-completion-return-key-behavior</span> = <span class="string">"complete"</span></span><br><span class="line"><span class="attr">auto-completion-tab-key-behavior</span> = <span class="string">"cycle"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用 shell 模块, 禁用模块时，需要加入 enable = false</span></span><br><span class="line"><span class="section">[[layers]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"shell"</span></span><br><span class="line"><span class="attr">enable</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加自定义插件</span></span><br><span class="line"><span class="section">[[custom_plugins]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"lilydjwg/colorizer"</span></span><br><span class="line"><span class="attr">merged</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="模块（layers）-快捷键"><a href="#模块（layers）-快捷键" class="headerlink" title="模块（layers）/快捷键"></a>模块（layers）/快捷键</h1><h2 id="模块使用"><a href="#模块使用" class="headerlink" title="模块使用"></a>模块使用</h2><ul><li><p>使能模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[layers]]</span><br><span class="line">name = "shell"</span><br><span class="line">default_position = "top"</span><br><span class="line">default_height = 30</span><br></pre></td></tr></table></figure></li><li><p>禁止模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[layers]]</span><br><span class="line">name = "shell"</span><br><span class="line">enable = false</span><br></pre></td></tr></table></figure></li></ul><p>以下介绍软件开发中经常使用的的模块及快捷键。</p><h2 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h2><p>在<code>.SpaceVim/autoload/SpaceVim/layers/tools.vim</code>文件中可以看到 tools 下有哪些插件。从作者关于 tools 这个模块的说明中可以得知，这些插件的快捷键都和插件的默认定义是一致的，并没有做任何更改。</p><p>下面选择几个非常有用的插件进行说明。</p><ul><li><p>MattesGroeger/vim-bookmarks – 标签相关</p><blockquote><p>在写代码是，需要经常转换行，这时候我们需要对要记住位置的行加入标签，然后进行跳转。</p></blockquote><p><img src="https://camo.githubusercontent.com/bc2bf1746e30c72d7ff5b79331231e8c388d068a/68747470733a2f2f7261772e6769746875622e636f6d2f4d617474657347726f656765722f76696d2d626f6f6b6d61726b732f6d61737465722f707265766965772e676966" alt=""></p></li></ul><table><thead><tr><th>Action</th><th>Shortcut</th><th>Command</th></tr></thead><tbody><tr><td>Add/remove bookmark at current line</td><td><code>mm</code></td><td><code>:BookmarkToggle</code></td></tr><tr><td>Add/edit/remove annotation at current line</td><td><code>mi</code></td><td><code>:BookmarkAnnotate &lt;TEXT&gt;</code></td></tr><tr><td>Jump to next bookmark in buffer</td><td><code>mn</code></td><td><code>:BookmarkNext</code></td></tr><tr><td>Jump to previous bookmark in buffer</td><td><code>mp</code></td><td><code>:BookmarkPrev</code></td></tr><tr><td>Show all bookmarks (toggle)</td><td><code>ma</code></td><td><code>:BookmarkShowAll</code></td></tr><tr><td>Clear bookmarks in current buffer only</td><td><code>mc</code></td><td><code>:BookmarkClear</code></td></tr><tr><td>Clear bookmarks in all buffers</td><td><code>mx</code></td><td><code>:BookmarkClearAll</code></td></tr><tr><td>Move up bookmark at current line</td><td><code>[count]mkk</code></td><td><code>:BookmarkMoveUp [&lt;COUNT&gt;]</code></td></tr><tr><td>Move down bookmark at current line</td><td><code>[count]mjj</code></td><td><code>:BookmarkMoveDown [&lt;COUNT&gt;]</code></td></tr><tr><td>Move bookmark at current line to another line</td><td><code>[count]mg</code></td><td><code>:BookmarkMoveToLine &lt;LINE&gt;</code></td></tr><tr><td>Save all bookmarks to a file</td><td></td><td><code>:BookmarkSave &lt;FILE_PATH&gt;</code></td></tr><tr><td>Load bookmarks from a file</td><td></td><td><code>:BookmarkLoad &lt;FILE_PATH&gt;</code></td></tr></tbody></table><h2 id="cscope"><a href="#cscope" class="headerlink" title="cscope"></a>cscope</h2><p>cscope 作用摘抄如下：</p><blockquote><ul><li>all references to a symbol</li><li>global definitions</li><li>functions called by a function</li><li>functions calling a function</li><li>text string</li><li>regular expression pattern</li><li>a file</li><li>files including a file</li></ul></blockquote><p>配置：</p><ol><li><p>安装cscope(建议源码安装)</p></li><li><p>源码根目录执行 cscope -Rbq(可以有更复杂的选项)</p></li><li><p>SpaceVim 配置文件中添加 cscope layer</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[layers]]</span><br><span class="line">name = 'cscope'</span><br></pre></td></tr></table></figure></li></ol><p>使用：</p><table><thead><tr><th>Key Binding</th><th>Description</th></tr></thead><tbody><tr><td><code>SPC m c =</code></td><td>Find assignments to this symbol</td></tr><tr><td><code>SPC m c i</code></td><td>Create cscope index</td></tr><tr><td><code>SPC m c c</code></td><td>Find functions called by this function</td></tr><tr><td><code>SPC m c C</code></td><td>Find functions calling this function</td></tr><tr><td><code>SPC m c d</code></td><td>find global definition of a symbol</td></tr><tr><td><code>SPC m c r</code></td><td>find references of a symbol</td></tr><tr><td><code>SPC m c f</code></td><td>find file</td></tr><tr><td><code>SPC m c F</code></td><td>find which files include a file</td></tr><tr><td><code>SPC m c e</code></td><td>search regular expression</td></tr><tr><td><code>SPC m c t</code></td><td>search text</td></tr></tbody></table><h2 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h2><p>GNU GLOBAL 作用官网摘抄如下：</p><blockquote><p>GNU GLOBAL is a source code tagging system that works the same way across diverse environments, such as Emacs editor, Vi editor, Less viewer, Bash shell, various web browsers, etc.</p><p>You can locate various objects, such as functions, macros, structs, classes, in your source files and move there easily. It is useful for hacking a large projects which contain many sub-directories, many <code>#ifdef</code> and many <code>main()</code>functions. It is similar to ctags or etags, but is different from them in the following two points:</p><ul><li>independence of any editor</li><li>capability to treat definition and reference</li></ul></blockquote><p>配置：</p><ol><li>安装 GNU GLOBAL (建议源码安装)</li><li>源码根目录执行 gtags (更复杂的选项请自行研究)</li><li>SpaceVim 配置文件中添加 gtags layer</li></ol><p>使用：</p><table><thead><tr><th>Key Binding</th><th>Description</th></tr></thead><tbody><tr><td><code>SPC m g c</code></td><td>create a tag database</td></tr><tr><td><code>SPC m g u</code></td><td>manually update tag database</td></tr><tr><td><code>SPC m g f</code></td><td>jump to a file in tag database</td></tr><tr><td><code>SPC m g d</code></td><td>find definitions</td></tr><tr><td><code>SPC m g r</code></td><td>find references</td></tr></tbody></table><h3 id="autocomplete"><a href="#autocomplete" class="headerlink" title="autocomplete"></a>autocomplete</h3><blockquote><p><a href="https://spacevim.org/layers/autocomplete/" target="_blank" rel="noopener">https://spacevim.org/layers/autocomplete/</a></p></blockquote><p>自动补全，写代码肯定是需要的。</p><p>示例配置如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable autocomplete layer</span></span><br><span class="line"><span class="section">[[layers]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">'autocomplete'</span></span><br><span class="line"><span class="attr">auto-completion-return-key-behavior</span> = <span class="string">"complete"</span></span><br><span class="line"><span class="attr">auto-completion-tab-key-behavior</span> = <span class="string">"smart"</span></span><br></pre></td></tr></table></figure><p>配置说明：</p><ul><li><code>auto-completion-return-key-behavior</code> – 回车键触发会触发如下动作：<ul><li><code>complete</code>: 使用当前选项补全</li><li><code>smart</code>: 使用当前选项补全，并展开代码段或者参数</li><li><code>nil</code>: 行为与enter键默认行为一致，会产生回车键的效果（换行）</li></ul></li><li><code>auto-completion-tab-key-behavior</code> – tab 键触发如下动作：<ul><li><code>smart</code> – 自动循环补全列表、展开代码块以及跳至下一个代码块的锚点（固定结构需要修改的地方）</li><li><code>cycle</code> – 自动循环补全列表</li><li><code>complete</code> – 插入当前选中的列表选项</li><li><code>nil</code> – 该行为和 Tab 的默认行为一致</li></ul></li></ul><h3 id="leaderf"><a href="#leaderf" class="headerlink" title="leaderf"></a>leaderf</h3><blockquote><p>搜索文件、函数列表、命令历史等</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[layers]]</span></span><br><span class="line">  name = "leaderf"</span><br></pre></td></tr></table></figure><p>最有用的应该就是模糊查找项目文件了：<code>ctrl-p</code> / <code>&lt;Leader&gt; f</code>[ <leader> 在 SpaceVim 中默认没有修改， 为 \ 键]</leader></p><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><blockquote><p>下文摘自官方文档</p></blockquote><h2 id="为什么选择-Toml-作为默认配置语言？"><a href="#为什么选择-Toml-作为默认配置语言？" class="headerlink" title="为什么选择 Toml 作为默认配置语言？"></a>为什么选择 Toml 作为默认配置语言？</h2><p>在往期的版本中，一直使用的 Vim 脚本作为配置文件，而 SpaceVim 读取配置文件的机制是 直接载入该脚本。Vim 在载入脚本时是边载入边执行的，这就意味着当你的配置文件中间部分 出现语法错误时，并不能阻止前半部分配置被载入，排错时非常有影响。</p><p>因此我们选择了另外一种更加健壮的语言来配置 SpaceVim，SpaceVim 会完整读取该配置文件， 如果文件中间出现语法错误，导致解析失败。那么该配置会被完全舍弃，而使用 SpaceVim 的 默认配置，这就大大降低了因配置文件错误导致 SpaceVim 运行出错的可能性。</p><p>在配置文件格式选择时，我们在 json、yaml、xml、toml 这四中文件格式之间也做了比较。</p><ol><li>yaml 依赖缩进，配置转移时易出错，不与考虑</li><li>xml 缺少 vim 解析库， 不与考虑</li><li>json 时一个比较好的配置信息传输格式，并且 Vim 有一个解析的函数，但是 json 格式 不支持注释，手写编辑时，阅读性太差。</li></ol><p>因此，我们选择了 Toml 作为默认的配置格式，并且解析后，缓存为 json 文件。SpaceVim 在启动时直接读取缓存 json 文件，效率更高。</p><h2 id="为什么-SpaceVim-颜色主题和官网不一致？"><a href="#为什么-SpaceVim-颜色主题和官网不一致？" class="headerlink" title="为什么 SpaceVim 颜色主题和官网不一致？"></a>为什么 SpaceVim 颜色主题和官网不一致？</h2><p>因为在 SpaceVim 中，默认情况下是启用了终端真色，因此你需要确保你的终端支持真色。 但是并不是每种终端默认都支持真色的。因此，当你的终端不支持真色时， 你可以在配置文件里面禁用真色支持：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable_guicolors = false</span><br></pre></td></tr></table></figure><h2 id="如何增加自定义快捷键？"><a href="#如何增加自定义快捷键？" class="headerlink" title="如何增加自定义快捷键？"></a>如何增加自定义快捷键？</h2><p>使用 Toml 作为默认配置文件后，无法在配置文件里面直接添加 Vim 快捷键， 这点让很多用户感到困惑。实际上，SpaceVim 支持指定载入配置时需要调用的函数。</p><p>比如，我需要加入这样一个快捷键，使用 <code>&lt;Leader&gt; w</code> 来保存当前文件。那么， 我需要修改配置文件，并指定一个载入时需要调用的方法：</p><p>修改 <code>~/.SpaceVim.d/init.toml</code>，加入 <code>bootstrap_before</code> 选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[options]</span><br><span class="line">  bootstrap_before = &quot;myspacevim#init&quot;</span><br></pre></td></tr></table></figure><p>添加文件 <code>~/.SpaceVim.d/autoload/myspacevim.vim</code>, 并加入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function! myspacevim#init() abort</span><br><span class="line">  nnoremap &lt;Leader&gt;w :w&lt;cr&gt;</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpaceVim简介&quot;&gt;&lt;a href=&quot;#SpaceVim简介&quot; class=&quot;headerlink&quot; title=&quot;SpaceVim简介&quot;&gt;&lt;/a&gt;SpaceVim简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;SpaceVim 是一个社区驱动的模块化 Vim 
      
    
    </summary>
    
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 环境搭建</title>
    <link href="http://yoursite.com/2018/08/01/Ubuntu%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/08/01/Ubuntu环境搭建/</id>
    <published>2018-08-01T15:25:31.000Z</published>
    <updated>2018-08-11T12:39:49.394Z</updated>
    
    <content type="html"><![CDATA[<p>以下是我每次安装 ubuntu 都会搭建的开发/娱乐环境，请读者参考。下面的内容比较精简，我主要是点出有这个东西，并且是我自己必备的东西，肯定也是蛮好用的，具体是什么，怎么用，网上已经有很多比我写的很好的轮子了，我就不重造了。另外如果你有好的推荐，也请告知我，我是工具/效率控，也想继续提升。</p><p><img src="http://oi435vw1u.bkt.clouddn.com/ubuntu.png" alt="ubuntu环境搭建"></p><h2 id="1-编辑器"><a href="#1-编辑器" class="headerlink" title="1. 编辑器"></a>1. 编辑器</h2><ul><li><p>neovim（更快的vim ?）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ninja-build gettext libtool libtool-bin autoconf automake cmake g++ pkg-config unzip</span><br><span class="line">git clone https://github.com/neovim/neovim.git</span><br><span class="line">make -j8</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">## 我最后使用的是 apt 安装，现在住的地方（颠沛流离啊）网络实在不行，会卡在某些下载处。</span><br><span class="line">sudo apt-get install neovim</span><br><span class="line">sudo apt-get install xclip</span><br><span class="line">sudo apt-get install xclip</span><br><span class="line">pip install neovim</span><br><span class="line">pip3 install neovim</span><br></pre></td></tr></table></figure></li><li><p>SpaceVim（neovim / vim 强大配置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sLf https://spacevim.org/install.sh | bash</span><br></pre></td></tr></table></figure><p>关于 SpaceVim 要说的很多，后续专门成文说明。</p></li><li><p>tmux（分屏工具）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y install libevent-dev libncurses-dev</span><br><span class="line">git clone https://github.com/tmux/tmux.git</span><br><span class="line">cd tmux</span><br><span class="line">sh autogen.sh</span><br><span class="line">./configure &amp;&amp; make</span><br><span class="line"></span><br><span class="line"># 去除&lt;200b&gt;[我从《tmux 2 Productive Mouse-Free Development》这本书拷贝配置的时候遇到这个问题]</span><br><span class="line">sed -i &apos;s/\xe2\x80\x8b//g&apos; inputfile</span><br></pre></td></tr></table></figure></li><li><p>typora</p><p>markdown写作神器，跨各种平台，推荐！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># optional, but recommended</span><br><span class="line"># sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span><br><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv BA300B7755AFCFAE</span><br><span class="line"># add Typora&apos;s repository</span><br><span class="line">sudo add-apt-repository &apos;deb https://typora.io/linux ./&apos;</span><br><span class="line">sudo apt-get update</span><br><span class="line"># install typora</span><br><span class="line">sudo apt-get install typora</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-命令行"><a href="#2-命令行" class="headerlink" title="2. 命令行"></a>2. 命令行</h2><ul><li><p>zsh + oh_my_zsh（zsh 及配置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y install zsh</span><br><span class="line">sudo apt -y install curl</span><br><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure></li><li><p>fzf（模糊搜索历史命令、文件等）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf</span><br><span class="line">~/.fzf/install</span><br></pre></td></tr></table></figure></li><li><p>z（快速跳转目录）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/rupa/z.git</span><br><span class="line">echo &quot;. ~/tools/z/z.sh&quot; &gt;&gt; ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></li><li><p>ag（快速搜索）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y automake pkg-config libpcre3-dev zlib1g-dev liblzma-dev</span><br><span class="line">cd the_silver_searcher &amp;&amp; ./build.sh</span><br><span class="line">make -j8 &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-工具"><a href="#3-工具" class="headerlink" title="3. 工具"></a><strong>3. 工具</strong></h2><ul><li><p>搜狗输入法</p></li><li><p>VNote（笔记软件）</p><p>本来有道云笔记很好用，可是就是没有 linux 版本…</p><p>VNote 跨三种平台，并且支持 vi 模式。</p><p>结合下面的坚果云，可以实现同步。</p></li><li><p>坚果云（同步文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.jianguoyun.com/static/exe/installer/ubuntu/nautilus_nutstore_amd64.deb</span><br><span class="line">sudo apt-get install gdebi</span><br><span class="line">sudo gdebi nautilus_nutstore_amd64.deb</span><br><span class="line"></span><br><span class="line"># SSL 连接错误解决方案</span><br><span class="line">sudo apt purge &apos;openjdk-*&apos;</span><br><span class="line">[ -d /usr/lib/jvm ] &amp;&amp; sudo mv /usr/lib/jvm /usr/lib/jvm-backup</span><br><span class="line">sudo apt install -y openjdk-8-jre</span><br></pre></td></tr></table></figure></li><li><p>Xmind-ZEN</p><p>思维导图，免费版就够用了，不过导出图片就有水印，土豪请支持正版。</p><p>效果请看本文第一图。</p></li></ul><h2 id="4-科学上网"><a href="#4-科学上网" class="headerlink" title="4. 科学上网"></a>4. 科学上网</h2><ul><li><p>vps</p><p>科学上网可以选择购买市面上的 vpn，简单方便，不过随时面临倒闭的风险，毕竟是国家重点照顾的领域。我相信在看这篇文章的朋友大部分是程序员，至少应该是 IT 从业者，所以我觉得应该自己购买 vps 搭梯子，多折腾。弄好了</p></li><li><p>安装Shadowsocks-qt5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/shadowsocks/shadowsocks-qt5/releases/download/v3.0.1/Shadowsocks-Qt5-3.0.1-x86_64.AppImage</span><br><span class="line">vpsIP</span><br><span class="line">ss端口</span><br><span class="line">ss密码</span><br><span class="line">aes-256-cfb（ss加密方式）</span><br><span class="line">1080</span><br></pre></td></tr></table></figure></li><li><p>代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pip</span><br><span class="line">sudo pip install genpac</span><br><span class="line">genpac --pac-proxy &quot;127.0.0.1:1080&quot; --output=&quot;autoproxy.pac&quot;</span><br><span class="line">Network proxy 设置: file:///home/longhai/autoproxy.pac</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-博客"><a href="#5-博客" class="headerlink" title="5. 博客"></a>5. 博客</h2><ul><li><p>hexo</p><p>简单，可定制，需折腾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install npm</span><br><span class="line">sudo npm install hexo-cli -g</span><br><span class="line">sudo npm install hexo -g</span><br><span class="line"></span><br><span class="line"># github 上创建名为 username.github.io 的空库（username为github账户）</span><br><span class="line">git clone https://github.com/longhaiqwe/longhaiqwe.github.io.git</span><br><span class="line"></span><br><span class="line">mkdir -p ~/blog/hexo</span><br><span class="line">cd hexo</span><br><span class="line">hexo init</span><br><span class="line">npm install hexo-generator-index –save </span><br><span class="line">npm install hexo-generator-index --save </span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag  --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-stylus</span><br><span class="line">npm install hexo-renderer-stylus --save</span><br><span class="line">npm install hexo-generator-feed </span><br><span class="line">npm install hexo-generator-feed  --save</span><br><span class="line">npm install hexo-generator-sitemap  --save</span><br><span class="line"></span><br><span class="line">## 或者可以使用如下一条命令解决：</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">## 并且好像上面那一条语句也可以不用执行～</span><br><span class="line"></span><br><span class="line">## Quick Start</span><br><span class="line">hexo new &quot;My New Post&quot;</span><br><span class="line">hexo server</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-持续更新"><a href="#6-持续更新" class="headerlink" title="6. 持续更新"></a>6. 持续更新</h2><ul><li><p>ubuntu  gnome-terminal 选中即复制</p><p>安装clipit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install clipit</span><br></pre></td></tr></table></figure><p>配置：打开clipit，在任务栏cliplt图标 右键–&gt;prefrences，勾选 User Primary(Selection) 和 Synchronize clipboards即可。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是我每次安装 ubuntu 都会搭建的开发/娱乐环境，请读者参考。下面的内容比较精简，我主要是点出有这个东西，并且是我自己必备的东西，肯定也是蛮好用的，具体是什么，怎么用，网上已经有很多比我写的很好的轮子了，我就不重造了。另外如果你有好的推荐，也请告知我，我是工具/效率
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
  </entry>
  
</feed>

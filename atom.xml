<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>longhai&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-07T16:06:39.430Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>龙海</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VSCode中C++插件推荐</title>
    <link href="http://yoursite.com/2019/09/07/VSCode/VSCode%E4%B8%ADC-%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    <id>http://yoursite.com/2019/09/07/VSCode/VSCode中C-插件推荐/</id>
    <published>2019-09-07T15:17:56.000Z</published>
    <updated>2019-09-07T16:06:39.430Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><ul><li><p>最近从 <code>vim</code> 转到 <code>VSCode</code>，在 google 搜索了 <strong>VSCode 中 C++ 插件推荐</strong> 这样的字眼，结果不尽如人意，是本文成文初衷。</p></li><li><p>本文只针对 C/C++ 开发，其他语言也有很多 niubility 的插件，本文不述。</p></li><li><p>本文不会从 VSCode 的安装开始讲起，所以需要你至少知道 VSCode 的安装、如何安装插件等基础知识（其实相当于不需要基础了）。</p></li><li><p>如下文，我将我认为必备的 C/C++ 插件分为了 <strong>3</strong> 个阶梯，重要性依次递减，同一阶梯内排名不分先后，因人而异。当然这 3 个阶梯呢，也是我拍脑袋想的。</p></li><li><p>所有插件只做简单描述，点到为止，具体如何使用、如何熟练使用，请自行研究，也可联系作者，非常乐意和您交流。</p></li></ul><p><strong>第一阶梯</strong></p><ul><li><p><strong>C/C++</strong> – 相信这是使用 VSCode 打开 C/C++ 文件第一时间会推荐的插件，也是必不可少的插件。</p></li><li><p><strong>VSCodeVim</strong> – 对于 vimer 来说，唯一转到 VSCode 的原因。</p></li><li><p><strong>ccls</strong> – 对于忍受不了 <code>ctags</code>、<code>gtags</code> 等基于静态符号索引的人来说，基于 <code>LSP</code> 的语义级别的符号检索才是首选。关于两者的区别，可以另外长篇大论了，这里不再赘述，可以参考文后链接博文。不过可以给出的结论是，基于语义的符号检索使用体验大大<strong>优于</strong>基于静态符号的检索。<strong>ccls 的学习需要一点成本，不过绝对是值得的。</strong></p></li></ul><p><strong>第二阶梯</strong></p><ul><li><p><strong>GitLens</strong> – 对于 <code>git</code> 的集成，这一个就够了。</p></li><li><p><strong>Bookmarks</strong> – 配合 <code>Vim</code> 插件，进行部分配置快捷键，达到极流畅的基于标签的快速跳转。</p></li><li><p><strong>Clang-Format</strong> – 可以设定格式器 <code>clang-format</code> 的位置（假如你的项目有自己的格式器，否则用默认即可），并且设置为保存文件是自动格式化。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">"editor.formatOnSave": true,</span><br><span class="line">"clang-format.executable": "/path/to/clang-format"</span><br></pre></td></tr></table></figure></li></ul><p><strong>第三阶梯</strong></p><ul><li><p><strong>Bracket Pair Colorizer</strong> – 对各种括号加上不同的颜色，对于阅读 C++ 之类的以括号标识作用域的代码，有一定帮助（有彩蛋）。另外还有一个类似的 <strong>Rainbow Brackets</strong> 可以达到这个效果，不过这个<strong>下载量</strong>明显不如 Bracket Pair Colorizer，我认为下载量可以作为插件质量的很重要的衡量标准。</p></li><li><p><strong>TODO Highlight</strong> – 高亮代码中的 <code>TODO</code>, <code>FIXME</code> 等关键字。</p></li><li><p><strong>vscode-icons</strong> – 与 C++ 关系不大，不过能让你的 VSCode 的图标更加丰富，整个 UI 看起来逼格更高。</p></li><li><p><strong>One Monokai Theme</strong> – 我个人认为比较漂亮的主题。</p></li></ul><p>本文没有附带插件的链接，也确实没有必要，VSCode 的插件安装是如此方便。</p><p>大家在使用中有什么好用的插件，也欢迎推荐。</p><p><strong>参考</strong></p><p><a href="https://zhuanlan.zhihu.com/p/31672451" target="_blank" rel="noopener">使用ccls：C++ language server</a></p><p><a href="https://zhuanlan.zhihu.com/p/37290578" target="_blank" rel="noopener">Vim 8 中 C/C++ 符号索引：LSP 篇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;最近从 &lt;code&gt;vim&lt;/code&gt; 转到 &lt;code&gt;VSCode&lt;/code&gt;，在 google 搜索了 &lt;strong&gt;VSCode 中 C++ 插件推荐&lt;/strong&gt; 这样的字眼，结果不
      
    
    </summary>
    
    
      <category term="VSCode" scheme="http://yoursite.com/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>图解《番茄工作法图解》</title>
    <link href="http://yoursite.com/2019/01/06/%E8%AF%BB%E4%B9%A6/%E5%9B%BE%E8%A7%A3%E3%80%8A%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B/"/>
    <id>http://yoursite.com/2019/01/06/读书/图解《番茄工作法图解》/</id>
    <published>2019-01-06T13:44:23.000Z</published>
    <updated>2019-09-08T08:51:00.061Z</updated>
    
    <content type="html"><![CDATA[<p>我经历过比较极端的两个职业阶段：</p><ul><li><strong>工作很清闲。</strong>那段时间，公司的主营业务变动，上层领导也是经常变换，导致我们下面干活的人，找不到一个清晰的目标。而我自己，也是整个公司所有员工的状态，就是准点上下班，甚至于上班时间也经常不知道该干什么。在这样的境况下，免不了的就是经常刷手机，明明处于一个“领着工资还可以学习充实自己”的位置，却浪费青春。</li><li><strong>工作极度饱和。</strong>现在的工作状态就是，一天忙得晕头转向，经常迷失于各种需求、功能开发，还有一堆堆的电话会议。虽然看起来非常充实，但是却经常找不到方向，一天下来，总是有一种啥事都没干成的感觉。</li></ul><p>也许你的工作也处于上面状态中的一种，那么番茄工作法是一个具体、切实可行的应对方法。</p><p>很早之前就接触了番茄工作法，也实践了差不多两年的时间。这里将番茄工作法稍微进行总结，主要目标是将知识梳理一下，同时内化为自己知识的一部分。</p><a id="more"></a><h2 id="什么是番茄工作法"><a href="#什么是番茄工作法" class="headerlink" title="什么是番茄工作法?"></a>什么是番茄工作法?</h2><img src="/2019/01/06/读书/图解《番茄工作法图解》/何为番茄工作法.png"><ol><li>从“活动清单”挑选今日待完成的任务</li><li>开启 25 分钟的番茄，开始工作</li><li>休息 5 分钟（每 4 个番茄时间休息 20 min），重复2</li><li>2 如果被打断，记录中断原因，视情况是否休息后重新开始 2</li><li>总结反思</li></ol><h2 id="番茄工作法的要点"><a href="#番茄工作法的要点" class="headerlink" title="番茄工作法的要点"></a>番茄工作法的要点</h2><img src="/2019/01/06/读书/图解《番茄工作法图解》/番茄工作法核心要点.png"><p>我认为番茄工作法只有两点最核心的内容：</p><ol><li><p><strong>一次只做一件事。</strong>在一个番茄内，只做一个你自己规划的最小单位的工作。这里会遇到 3 种情况：</p><ul><li><p>这个工作刚好在这个番茄内完成。皆大欢喜，赶紧给自己放 5 min中的小假。</p></li><li><p>这项工作在一个番茄内没有做完。你可以安排接下来的番茄继续，或者有更高优先级的待办事项插队，你可以记录一下，完成更高优先级的事情后，接着来做这个工作。</p></li><li>一个番茄还没结束，这项工作就已经做完了。这个时候尝试“过度学习”，可以回顾这个番茄的工作思路，反思有没有更好的解决办法，或者重复做一遍加深印象，都是不错的选择。</li></ul></li><li><p><strong>立即去做。</strong>没其他的，就是干。 </p></li></ol><h2 id="如何挑选任务？"><a href="#如何挑选任务？" class="headerlink" title="如何挑选任务？"></a>如何挑选任务？</h2><p>下图是我写这篇文章的一个活动清单和今日待办的小例子。</p><img src="/2019/01/06/读书/图解《番茄工作法图解》/活动清单+今日待办.png"><h3 id="从活动清单说起"><a href="#从活动清单说起" class="headerlink" title="从活动清单说起"></a>从活动清单说起</h3><p>活动清单，指的就是你自己规划的需要做的所有事项。全部罗列出来，可以不用考虑重要程度和优先级，仅仅只是言简意赅的写下来即可。</p><p>所以活动清单应该是一个无限容量（假如你永远不去完成清单上的事情，同时又一直往清单上添加事项）的列表。</p><h3 id="今日待办VS活动清单"><a href="#今日待办VS活动清单" class="headerlink" title="今日待办VS活动清单"></a>今日待办VS活动清单</h3><p>活动清单列完之后，一天的工作开始就是从活动清单中找出最重要的活动，填到今日待办中。</p><p>我们经常听到时间管理的概念，这个挑选活动的过程，其实就是良好的时间管理的基础。</p><p>当我们决定今天要完成哪些事情的时候，就应当用全局的眼光去判断，避免陷入一些琐事当中。</p><h2 id="怎么对待中断？"><a href="#怎么对待中断？" class="headerlink" title="怎么对待中断？"></a>怎么对待中断？</h2><p>不可避免的是，在 1 个番茄钟的执行过程中，一定会遇到被中断的情况。可以是外部的，譬如你的同事请教你问题；也可以是内部的，譬如你突然想起一件很重要并且需要立即处理的事情。</p><p>遇到中断，可以用下面 3 个步骤应对：</p><ul><li><strong>接受</strong>。首先，必须承认中断时肯定存在的，在番茄钟结束前终止，也是一个正常现象。</li><li><strong>记录</strong>。遇到中断，可以记录下来，分为内部和外部中断进行区分，可以作为后续总结反思的依据。</li><li><strong>继续或结束</strong>。对于耗时比较短的、不需要立即处理的中断，将其加入到待办事项或者活动清单中；对于耗时较长、且需要立即处理的中断，结束当前番茄钟转而处理优先级更高的中断事件即可。</li></ul><h2 id="怎样预估每项任务需要的番茄数？"><a href="#怎样预估每项任务需要的番茄数？" class="headerlink" title="怎样预估每项任务需要的番茄数？"></a>怎样预估每项任务需要的番茄数？</h2><p>对于每项任务需要的番茄数，我们只能使用猜测和预估的手段。</p><p>当然，一开始的预估，肯定是不准的。因为我们通常会对自己的能力和所处的环境做<strong>过于乐观</strong>的判断，即使考虑到了这一点。</p><p>我自己在使用番茄钟的过程中，也无数次的乐观估计，尽管多次告诉自己不要低估任务的难度，至今还是免不了要对番茄数做几次调整。</p><p>不过没有关系，只要我们认真总结，不断从失败的经验中获取历史数据，总能慢慢的趋向于正确值。</p><p>遇到了预估失败也没有关系，将其记录下来，作为下次预估的经验就好。</p><h2 id="我们应该总结什么，反思什么？"><a href="#我们应该总结什么，反思什么？" class="headerlink" title="我们应该总结什么，反思什么？"></a>我们应该总结什么，反思什么？</h2><p>需要总结的很多，每天能完成多少个番茄，每天都有哪些中断，预估的番茄数都有哪些修改？</p><p>而与之对应的，我们需要反思的就是，每天给自己设定多少个番茄是合适的，哪些中断是可以避免的，预估番茄数怎么样才能做到更加精准？</p><p>当然，总结和反思的目的，在于持续改善。只要坚持，一定会有收获。</p><h2 id="推荐工具"><a href="#推荐工具" class="headerlink" title="推荐工具"></a>推荐工具</h2><ul><li>活动清单+今日待办：Todoist</li><li>番茄时钟：Pomotodo</li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>对于番茄钟的使用，因人而异。</p><p>有人坚持数年，并有很好的回报；也有人坚持 1 个月，发现并不适合自己，所以放弃。</p><p>我相信很多人都听过“心流”的概念，它强调的是创建一段超长的时间，全身心的投入而不被打断。我想这与番茄时钟法的每 25 分钟休息，是完全不同的理念。</p><p>“心流”，我没有研究过，但是它的存在与流行必然存在其中的道理，后续我也会尝试去学习。</p><p>找到适合你的，才是最重要的。</p><p><a href="https://book.douban.com/subject/5916234/" target="_blank" rel="noopener">《番茄工作法图解》- 豆瓣</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我经历过比较极端的两个职业阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工作很清闲。&lt;/strong&gt;那段时间，公司的主营业务变动，上层领导也是经常变换，导致我们下面干活的人，找不到一个清晰的目标。而我自己，也是整个公司所有员工的状态，就是准点上下班，甚至于上班时间也经常不知道该干什么。在这样的境况下，免不了的就是经常刷手机，明明处于一个“领着工资还可以学习充实自己”的位置，却浪费青春。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作极度饱和。&lt;/strong&gt;现在的工作状态就是，一天忙得晕头转向，经常迷失于各种需求、功能开发，还有一堆堆的电话会议。虽然看起来非常充实，但是却经常找不到方向，一天下来，总是有一种啥事都没干成的感觉。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也许你的工作也处于上面状态中的一种，那么番茄工作法是一个具体、切实可行的应对方法。&lt;/p&gt;
&lt;p&gt;很早之前就接触了番茄工作法，也实践了差不多两年的时间。这里将番茄工作法稍微进行总结，主要目标是将知识梳理一下，同时内化为自己知识的一部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>gdb攻略</title>
    <link href="http://yoursite.com/2018/12/24/gdb/gitchat-gdb-course/"/>
    <id>http://yoursite.com/2018/12/24/gdb/gitchat-gdb-course/</id>
    <published>2018-12-23T23:42:18.000Z</published>
    <updated>2019-01-06T14:49:34.476Z</updated>
    
    <content type="html"><![CDATA[<ol><li><code>strip</code>命令可以移除可执行程序的调试信息</li><li>gdb 调试方式<ol><li>直接调试目标程序</li><li>附加进程<ul><li>当调试完程序想结束此次调试时，而且不对当前进程有任何影响，也就是说想让这个程序继续运行，可以在 GDB 的命令行界面输入 <strong>detach</strong> 命令让程序与 GDB 调试器分离，这样被调试程序就可以继续运行了</li></ul></li><li>调试 core 文件<ul><li>使用 <code>ulimit -c unlimited</code>（<strong>unlimited</strong> 是 <strong>-c</strong> 选项值）直接修改成不限制大小（生成 core 文件）</li><li>加入到<code>/etc/profile</code>永久生效</li></ul></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;code&gt;strip&lt;/code&gt;命令可以移除可执行程序的调试信息&lt;/li&gt;
&lt;li&gt;gdb 调试方式&lt;ol&gt;
&lt;li&gt;直接调试目标程序&lt;/li&gt;
&lt;li&gt;附加进程&lt;ul&gt;
&lt;li&gt;当调试完程序想结束此次调试时，而且不对当前进程有任何影响，也就是说想让这个程序
      
    
    </summary>
    
    
      <category term="gdb" scheme="http://yoursite.com/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>C++11多线程 -【5】使用mutex避免竞争条件</title>
    <link href="http://yoursite.com/2018/11/24/C++/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E3%80%905%E3%80%91%E4%BD%BF%E7%94%A8mutex%E9%81%BF%E5%85%8D%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/11/24/C++/C++11多线程-【5】使用mutex避免竞争条件/</id>
    <published>2018-11-24T14:29:56.000Z</published>
    <updated>2018-11-25T14:32:30.438Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://thispointer.com/c11-multithreading-part-5-using-mutex-to-fix-race-conditions/" target="_blank" rel="noopener">C++11 Multithreading – Part 5: Using mutex to fix Race Conditions</a></p></blockquote><p>本文讨论一下怎么在多线程中用 mutex 锁对共享数据进行保护，避免竞争条件的发生。</p><p>在多线程环境，我们通过在修改或者读取共享数据之前对 mutex 进行加锁、在修改数据之后解锁 mutex 来修复竞争条件的问题。</p><h2 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h2><p>C++11 线程库中，mutex 被定义在<code>&lt;mutex&gt;</code>头文件中，<code>std::mutex</code>对象代表一个信号量（mutex）。</p><p>mutex 的两个重要函数：</p><ul><li>lock()</li><li>unlock()</li></ul><p>在上篇文章中，我们举了一个<a href="https://longhaiqwe.github.io/2018/11/22/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E3%80%904%E3%80%91%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E4%B8%8E%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6/" target="_blank" rel="noopener">竞争条件的例子</a>。</p><p>下面，我们使用 mutex 解决上篇文章中最后留下的问题。</p><p>Wallet 提供了一个增加钱的方法，同一个 Wallet 对象被多个线程同时使用，所以我们需要对<code>addMoney</code>函数加锁。</p><p>在增加钱之前获取锁，然后在函数返回前释放锁。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wallet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> mMoney;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Wallet() :mMoney(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; money; ++i)</span><br><span class="line">     &#123;</span><br><span class="line">        mMoney++;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试函数与上节相同。</p><p>函数运行结果，屏幕上不会有任何打印。也就是说程序保证了不会有钱包里面的钱少于 5000 的情况出现。</p><p>因为 mutex 锁保证了在必须在一个线程完成对钱的数量的修改操作之后，另一个线程才能修改钱的数量值。</p><p>但是假如我们在函数结束之前忘记对 mutex 进行释放（unlock）的话，就会导致其他线程一直等待锁。</p><p>在加锁后异常退出等情况下，可能出现上述类似的场景。为了避免出现此类情况，可以使用 std::lock_guard。</p><h2 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h2><p>std::lock_guard 是一个类模板，它实现了 mutex 的 <a href="https://zh.wikipedia.org/zh-hans/RAII" target="_blank" rel="noopener">RAII</a>。</p><p>它将 mutex 包装在其对象内部，并将附加的 mutex 锁定在其构造函数中。当调用析构函数时，它释放 mutex。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wallet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> mMoney;</span><br><span class="line"><span class="built_in">std</span>::mutex mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Wallet() :mMoney(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lockGuard(mutex);</span><br><span class="line">    <span class="comment">// In constructor it locks the mutex</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; money; ++i) &#123;</span><br><span class="line">  <span class="comment">// If some exception occurs at this</span></span><br><span class="line">  <span class="comment">// poin then destructor of lockGuard</span></span><br><span class="line">  <span class="comment">// will be called due to stack unwinding.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  mMoney++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Once function exits, then destructor</span></span><br><span class="line">  <span class="comment">// of lockGuard Object will be called.</span></span><br><span class="line">  <span class="comment">// In destructor it unlocks the mutex.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://thispointer.com/c11-multithreading-part-5-using-mutex-to-fix-race-conditions/&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11多线程 -【4】数据共享与竞争条件</title>
    <link href="http://yoursite.com/2018/11/22/C++/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E3%80%904%E3%80%91%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E4%B8%8E%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/11/22/C++/C++11多线程-【4】数据共享与竞争条件/</id>
    <published>2018-11-21T23:32:08.000Z</published>
    <updated>2018-11-24T15:04:37.244Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://thispointer.com/c11-multithreading-part-4-data-sharing-and-race-conditions/" target="_blank" rel="noopener">C++11 Multithreading – Part 4: Data Sharing and Race Conditions</a></p></blockquote><p>在多线程情况下要共享数据很简单，但是会导致程序出现问题，其中一个问题就是本文要讲到的竞争条件（或者叫共享竞争，英文原名<strong>race conditions</strong>）。</p><h2 id="什么是竞争条件"><a href="#什么是竞争条件" class="headerlink" title="什么是竞争条件"></a>什么是竞争条件</h2><p>竞争条件是多线程程序中才会出现的问题。</p><p>考虑这种情况：两个或多个线程对同一块内存并行地执行一系列操作。当它们对这块内存进行同时修改，有时就会导致意想不到的结果。</p><p>这就是竞争条件。</p><p>竞争条件问题一般很难定位和重现，因为它不是必现的。只有当线程以一定的顺序执行（这种情况是随机的），问题才能得到复现。</p><p>下面看一个示例。</p><h2 id="竞争条件示例"><a href="#竞争条件示例" class="headerlink" title="竞争条件示例"></a>竞争条件示例</h2><p>看下面这个 Wallet 类，它包含 addMoney 和 getMoney 的成员函数。</p><p>addMoney 函数增加指定数量的钱， getMoney 获取钱包里面钱的数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wallet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> mMoney;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Wallet() :mMoney(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; money; ++i)</span><br><span class="line">     &#123;</span><br><span class="line">        mMoney++;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们创建 5 个线程，并行地调用 addMoney 给钱包增加 1000 块。</p><p>假如钱包里一开始没有钱， 那么按理来说，执行完上面的操作之后，钱包里面应该有 5000 块。</p><p>但是由于多个线程对共享数据进行修改，就很有可能导致最终钱的数量远小于 5000 块。</p><p>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">testMultithreadedWallet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Wallet walletObject;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</span><br><span class="line">        threads.push_back(<span class="built_in">std</span>::thread(&amp;Wallet::addMoney, &amp;walletObject, <span class="number">1000</span>));</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.size(); i++)</span><br><span class="line">   &#123;</span><br><span class="line">       threads.at(i).join();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> walletObject.getMoney();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1000</span>; k++)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span>((val = testMultithreadedWallet()) != <span class="number">5000</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error at count = "</span>&lt;&lt;k&lt;&lt;<span class="string">" Money in Wallet = "</span>&lt;&lt;val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我本机运行的结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Error at count = 1 Money in Wallet = 4086</span><br><span class="line">Error at count = 18 Money in Wallet = 4524</span><br><span class="line">Error at count = 63 Money in Wallet = 4170</span><br><span class="line">Error at count = 81 Money in Wallet = 4275</span><br><span class="line">Error at count = 97 Money in Wallet = 4076</span><br><span class="line">Error at count = 98 Money in Wallet = 4672</span><br><span class="line">Error at count = 113 Money in Wallet = 4663</span><br><span class="line">Error at count = 137 Money in Wallet = 4428</span><br><span class="line">Error at count = 140 Money in Wallet = 4765</span><br><span class="line">Error at count = 145 Money in Wallet = 4515</span><br><span class="line">Error at count = 166 Money in Wallet = 4176</span><br><span class="line">Error at count = 167 Money in Wallet = 4198</span><br><span class="line">Error at count = 168 Money in Wallet = 4172</span><br><span class="line">Error at count = 229 Money in Wallet = 4850</span><br><span class="line">Error at count = 230 Money in Wallet = 4496</span><br><span class="line">Error at count = 231 Money in Wallet = 4496</span><br><span class="line">Error at count = 238 Money in Wallet = 4409</span><br><span class="line">Error at count = 398 Money in Wallet = 4256</span><br><span class="line">Error at count = 428 Money in Wallet = 4743</span><br><span class="line">Error at count = 561 Money in Wallet = 4581</span><br><span class="line">Error at count = 562 Money in Wallet = 4987</span><br><span class="line">Error at count = 563 Money in Wallet = 4737</span><br><span class="line">Error at count = 579 Money in Wallet = 4912</span><br><span class="line">Error at count = 581 Money in Wallet = 4290</span><br><span class="line">Error at count = 623 Money in Wallet = 4718</span><br><span class="line">Error at count = 634 Money in Wallet = 4649</span><br><span class="line">Error at count = 649 Money in Wallet = 3000</span><br><span class="line">Error at count = 658 Money in Wallet = 4385</span><br><span class="line">Error at count = 659 Money in Wallet = 4209</span><br><span class="line">Error at count = 661 Money in Wallet = 4793</span><br><span class="line">Error at count = 685 Money in Wallet = 4557</span><br><span class="line">Error at count = 718 Money in Wallet = 4000</span><br><span class="line">Error at count = 735 Money in Wallet = 4277</span><br><span class="line">Error at count = 770 Money in Wallet = 4931</span><br><span class="line">Error at count = 789 Money in Wallet = 4645</span><br><span class="line">Error at count = 874 Money in Wallet = 4396</span><br><span class="line">Error at count = 886 Money in Wallet = 4427</span><br><span class="line">Error at count = 938 Money in Wallet = 3013</span><br><span class="line">Error at count = 939 Money in Wallet = 4084</span><br><span class="line">Error at count = 959 Money in Wallet = 4700</span><br><span class="line">Error at count = 965 Money in Wallet = 4406</span><br><span class="line">Error at count = 990 Money in Wallet = 4250</span><br></pre></td></tr></table></figure><p>这就是竞争条件：由于多个线程同时对一块内存进行修改，导致非预期结果。</p><h2 id="为什么会出现竞争条件？"><a href="#为什么会出现竞争条件？" class="headerlink" title="为什么会出现竞争条件？"></a>为什么会出现竞争条件？</h2><p>还是针对上面的例子进行分析。</p><p>多个线程并发的对同一个 mMoney 进行增加。虽然 <code>mMoney++</code> 看起来像是一行，但其实他会被转换为3条机器指令：</p><ul><li>从寄存器加载 mMoney</li><li>增加寄存器的值</li><li>用寄存器的值更新 mMoney</li></ul><p>现在考虑以下如下场景：</p><table><thead><tr><th>Thread1</th><th>Thread2</th></tr></thead><tbody><tr><td>从寄存器加载 mMoney</td><td></td></tr><tr><td></td><td>从寄存器加载 mMoney</td></tr><tr><td>增加寄存器的值</td><td></td></tr><tr><td></td><td>增加寄存器的值</td></tr><tr><td>用寄存器的值更新 mMoney</td><td></td></tr><tr><td></td><td>用寄存器的值更新 mMoney</td></tr></tbody></table><p>在这种场景下，mMoney 的值只会增加一次，因为Thread1的增加会被Thread的增加覆写。</p><p>假设操作之前 mMoney 的值是46，并且如上表它会被增加两次，也就是说我们预期的结果是48，但是由于条件竞争导致结果会是47。</p><h2 id="如何fix竞争条件"><a href="#如何fix竞争条件" class="headerlink" title="如何fix竞争条件"></a>如何fix竞争条件</h2><p>为了解决这个问题，我们需要使用锁机制，即每个线程需要在修改或读取共享数据之前获取锁，并且在修改数据之后，每个线程应该解锁锁。</p><p>我们会在系列文章的下篇进行详细的讲解，敬请期待。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://thispointer.com/c11-multithreading-part-4-data-sharing-and-race-conditions/&quot; target=&quot;_blank&quot; rel=&quot;noo
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11多线程 -【3】传参给线程</title>
    <link href="http://yoursite.com/2018/11/13/C++/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E3%80%903%E3%80%91%E4%BC%A0%E5%8F%82%E7%BB%99%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/11/13/C++/C++11多线程-【3】传参给线程/</id>
    <published>2018-11-13T15:01:49.000Z</published>
    <updated>2018-11-21T23:37:38.210Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://thispointer.com/c11-multithreading-part-3-carefully-pass-arguments-to-threads/" target="_blank" rel="noopener">C++11 Multithreading – Part 3: Carefully Pass Arguments to Threads</a></p></blockquote><p>要将参数传递给线程关联的可调用对象或函数，只需将参数传递给 std::thread 构造函数。</p><p>默认情况下，所有参数都被复制到新线程的内部存储中。</p><h2 id="向-C-11-中的-std-thread-传递简单参数"><a href="#向-C-11-中的-std-thread-传递简单参数" class="headerlink" title="向 C++ 11 中的 std::thread 传递简单参数"></a>向 C++ 11 中的 std::thread 传递简单参数</h2><p>如下是一个简单示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCallback</span><span class="params">(<span class="keyword">int</span> x, <span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Passed Number = "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Passed String = "</span>&lt;&lt;str&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Sample String"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(threadCallback, x, str)</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何不将参数传递给-C-11-中的线程"><a href="#如何不将参数传递给-C-11-中的线程" class="headerlink" title="如何不将参数传递给 C++ 11 中的线程"></a>如何不将参数传递给 C++ 11 中的线程</h2><blockquote><p>译者注：这里的标题感觉和下文的内容不是很符合，“什么情况不能将参数传递给线程”更为合适？</p></blockquote><p>不要将变量的地址从本地堆栈传递给线程的回调函数。因为线程 1 中的局部变量可能超出范围，但是线程 2 仍然试图通过其地址访问它。</p><p>在这种情况下，访问无效地址会导致意外行为。</p><p>请看如下示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newThreadCallback</span><span class="params">(<span class="keyword">int</span> * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside Thread :  "</span><span class="string">" : p = "</span>&lt;&lt;p&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">( <span class="number">1000</span> )</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for( dura );</span><br><span class="line">    *p = <span class="number">19</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startNewThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside Main Thread :  "</span><span class="string">" : i = "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(newThreadCallback,&amp;i)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside Main Thread :  "</span><span class="string">" : i = "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    startNewThread();</span><br><span class="line">    <span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">( <span class="number">2000</span> )</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for( dura );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，将指向堆上内存的指针传递给线程时也要小心。因为在新线程试图访问内存之前，一些线程可能会删除该内存。</p><p>在这种情况下，访问无效地址会导致意外行为。</p><p>请看如下示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newThreadCallback</span><span class="params">(<span class="keyword">int</span> * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside Thread :  "</span><span class="string">" : p = "</span>&lt;&lt;p&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">( <span class="number">1000</span> )</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for( dura );</span><br><span class="line">    *p = <span class="number">19</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startNewThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * p = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside Main Thread :  "</span><span class="string">" : *p = "</span>&lt;&lt;*p&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(newThreadCallback,p)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    startNewThread();</span><br><span class="line">    <span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">( <span class="number">2000</span> )</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for( dura );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何在-C-11-中将引用传递给-std-thread"><a href="#如何在-C-11-中将引用传递给-std-thread" class="headerlink" title="如何在 C++ 11 中将引用传递给 std::thread"></a>如何在 C++ 11 中将引用传递给 std::thread</h2><p>因为参数被复制到新线程堆栈，所以，如果你需要以普通方式传递引用，如下例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCallback</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> &amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp; y = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> &amp;&gt;(x);</span><br><span class="line">    y++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside Thread x = "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"In Main Thread : Before Thread Start x = "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(threadCallback, x)</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"In Main Thread : After Thread Joins x = "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In Main Thread : Before Thread Start x = 9</span><br><span class="line">Inside Thread x = 10</span><br><span class="line">In Main Thread : After Thread Joins x = 9</span><br></pre></td></tr></table></figure><p>即使<code>threadCallback</code>接受引用作为参数，但进行了更改之后，在线程之外也不可见。</p><p>这是因为线程函数<code>threadCallback</code>中的 x 是在新线程堆栈中复制的临时值的引用。</p><p>怎样修复上面的问题？</p><p>使用<code>std::ref()</code>，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCallback</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> &amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp; y = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> &amp;&gt;(x);</span><br><span class="line">    y++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside Thread x = "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"In Main Thread : Before Thread Start x = "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    std::thread threadObj(threadCallback,std::ref(x));</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"In Main Thread : After Thread Joins x = "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In Main Thread : Before Thread Start x = 9</span><br><span class="line">Inside Thread x = 10</span><br><span class="line">In Main Thread : After Thread Joins x = 10</span><br></pre></td></tr></table></figure><h2 id="将指向类成员函数的指针作为线程函数"><a href="#将指向类成员函数的指针作为线程函数" class="headerlink" title="将指向类成员函数的指针作为线程函数"></a>将指向类成员函数的指针作为线程函数</h2><p>将指向成员函数的指针作为回调函数传递，将指向对象的指针作为第二个参数传递。</p><p>看下面的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DummyClass()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    DummyClass(<span class="keyword">const</span> DummyClass &amp; obj)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sampleMemberFunction</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside sampleMemberFunction "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    DummyClass dummyObj;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(&amp;DummyClass::sampleMemberFunction,&amp;dummyObj, x)</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Inside sampleMemberFunction 10</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://thispointer.com/c11-multithreading-part-3-carefully-pass-arguments-to-threads/&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11多线程-【2】线程的join和detach</title>
    <link href="http://yoursite.com/2018/10/28/C++/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E3%80%902%E3%80%91%E7%BA%BF%E7%A8%8B%E7%9A%84join%E5%92%8Cdetach-md/"/>
    <id>http://yoursite.com/2018/10/28/C++/C++11多线程-【2】线程的join和detach-md/</id>
    <published>2018-10-28T11:47:34.000Z</published>
    <updated>2018-10-28T13:40:47.565Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://thispointer.com/c11-multithreading-part-2-joining-and-detaching-threads/" target="_blank" rel="noopener">C++11 Multithreading – Part 2: Joining and Detaching Threads</a></p></blockquote><p>本文介绍线程对象 std::thread 的 joining 和 detaching。</p><h2 id="使用-std-thread-join-进行线程的-joining"><a href="#使用-std-thread-join-进行线程的-joining" class="headerlink" title="使用 std::thread::join() 进行线程的 joining"></a>使用 std::thread::join() 进行线程的 joining</h2><p>一旦一个线程开始之后，另一个线程可以等待此线程结束。</p><p>需要等待的线程可以调用 std::thread 的 join() 函数来实现上述功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">th</span><span class="params">(funcPtr)</span></span>;</span><br><span class="line"><span class="comment">//some code</span></span><br><span class="line">th.join();</span><br></pre></td></tr></table></figure><p>下面看一个简单的例子。</p><p>假设主线程需要启动 10 个工作线程，开始这些线程之后，主线程需要等待这些线程结束。等 joining 所有的线程之后，主程序继续运行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Worker Thread "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is Executing"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threadList;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        threadList.push_back(<span class="built_in">std</span>::thread(WorkerThread()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待所有的工作线程结束，即对每一个 std::thread 对象调用 join() 函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"wait for all the worker thread to finish"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::for_each(threadList.begin(), threadList.end(), <span class="built_in">std</span>::mem_fn(&amp;<span class="built_in">std</span>::thread::join));</span><br><span class="line">    <span class="comment">// 下面这条语句是最后打印的</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Exiting from Main Thread"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-std-thread-detach-进行线程的-detaching"><a href="#使用-std-thread-detach-进行线程的-detaching" class="headerlink" title="使用 std::thread::detach() 进行线程的 detaching"></a>使用 std::thread::detach() 进行线程的 detaching</h2><p>detached 线程也被称为守护/后台进程。对线程进行 detached（翻译成分离？）操作，需要使用对 std::thread 对象调用 std::detach() 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">th</span><span class="params">(funcPtr)</span></span>;</span><br><span class="line">th.detach();</span><br></pre></td></tr></table></figure><h2 id="小心调用线程的-detach-和-join"><a href="#小心调用线程的-detach-和-join" class="headerlink" title="小心调用线程的 detach() 和 join()"></a>小心调用线程的 detach() 和 join()</h2><p><strong>案例1：不要在没有相关执行线程的 std::thread 对象上调用 join() 或 detach()</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::thread threadObj( (WorkerThread()) );</span><br><span class="line">threadObj.join();</span><br><span class="line">threadObj.join(); <span class="comment">// 会导致程序中断</span></span><br></pre></td></tr></table></figure><p>对线程对象调用 join() 函数，则当这个 join() 返回时，std::thread 对象就没有了与之相关联的线程。对这样的 std::thread 对象再次进行 join() 函数调用时，就会导致程序中断。</p><p>同理，调用 detach() 一样会使得 std::thread 对象不与其他任何的线程关联。在这种情况下，再次调用 detach() 会中断程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::thread threadObj( (WorkerThread()) );</span><br><span class="line">threadObj.detach();</span><br><span class="line">threadObj.detach(); <span class="comment">// 会导致程序中断</span></span><br></pre></td></tr></table></figure><p>因此，在调用 join() 或者 detach() 之前，我们每次都应该检查线程是否是 join-able 的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">std::thread threadObj( (WorkerThread()) );</span><br><span class="line"><span class="keyword">if</span>(threadObj.joinable())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Detaching Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj.detach();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(threadObj.joinable())    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Detaching Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj.detach();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::thread threadObj2( (WorkerThread()) );</span><br><span class="line"><span class="keyword">if</span>(threadObj2.joinable())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Joining Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj2.join();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(threadObj2.joinable())    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Joining Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例2：永远不要忘记在有关联的执行线程的 std::thread 对象上调用 join 或者 detach</strong></p><p>假如对一个有关联执行线程的 std::thread 对象并没有调用 join() 也没有调用 thread()，则在对象的析构的过程中会中断程序。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Worker Thread "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::thread threadObj((WorkerThread()));</span><br><span class="line">    <span class="comment">// 程序会中断，因为既没有调用 join() 也没有调用 detach()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样在异常情况下，我们也不能忘记调用 join() 或者 detach()。</p><p>为了防止这种情况，我们应该使用 ESOURCE ACQUISITION IS INITIALIZATION (RAII)。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadRAII</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::thread &amp;m_thread;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ThreadRAII(<span class="built_in">std</span>::thread &amp;threadObj) : m_thread(threadObj) &#123;&#125;</span><br><span class="line">    ~ThreadRAII() &#123;</span><br><span class="line">        <span class="comment">// 假如 joinable 则调用 detach</span></span><br><span class="line">        <span class="keyword">if</span> (m_thread.joinable()) &#123;</span><br><span class="line">            m_thread.detach();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread_function executing"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注释掉这行，程序会 crash</span></span><br><span class="line">    <span class="function">ThreadRAII <span class="title">wrapperObj</span><span class="params">(threadObj)</span></span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://thispointer.com/c11-multithreading-part-2-joining-and-detaching-threads/&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11多线程-【1】创建线程的三种方式</title>
    <link href="http://yoursite.com/2018/10/17/C++/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E3%80%901%E3%80%91%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/17/C++/C++11多线程-【1】创建线程的三种方式/</id>
    <published>2018-10-17T15:01:00.000Z</published>
    <updated>2018-10-28T13:40:40.597Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://thispointer.com/c-11-multithreading-part-1-three-different-ways-to-create-threads/" target="_blank" rel="noopener">C++11 Multithreading – Part 1 : Three Different ways to Create Threads</a></p></blockquote><p>本篇介绍如何在 C++11 中使用 std::thread 来创建线程。</p><h2 id="C-11-线程库介绍"><a href="#C-11-线程库介绍" class="headerlink" title="C++11 线程库介绍"></a>C++11 线程库介绍</h2><p>传统的C++只支持单线程编程。新的 C++ 标准 (即 C++11 或 C++0x) 于 2011 年发布。 C++11 中引入了一个新的线程库。</p><p><strong>编译器要求：</strong>  </p><p><strong>Linux:</strong> gcc 4.8.1 （完整的并发支持）<br><strong>Windows:</strong> Visual Studio 2012 and MingW</p><p><strong>Linux 下如何编译：</strong> <code>g++ –std=c++11 sample.cpp -lpthread</code></p><h2 id="C-11-线程创建"><a href="#C-11-线程创建" class="headerlink" title="C++11 线程创建"></a>C++11 线程创建</h2><p>每一个 C++11 程序都包含一个主线程即 main() 函数。 在 C++11 中我们可以通过创建 std::thread 对象来创建新的线程。</p><p>每个 std::thread 对象都可以与一个线程相关联。 </p><p>需要引用的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="std-thread的构造函数中接受什么参数？"><a href="#std-thread的构造函数中接受什么参数？" class="headerlink" title="std::thread的构造函数中接受什么参数？"></a>std::thread的构造函数中接受什么参数？</h3><p>我们可以给 std::thread 对象添加函数，这个回调函数将在这个新线程启动时执行。这些回调可以是：</p><p>1.) 函数指针<br>2.) 函数对象<br>3.) Lambda 函数</p><p>创建 thread 对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">thObj</span><span class="params">(&lt;CALLBACK&gt;)</span></span>;</span><br></pre></td></tr></table></figure><p>新线程将在创建新对象后立即启动，并将并行地执行（当参数）传递给线程的回调函数。 </p><p>此外，任何线程都可以通过调用某线程对象上的 join( ) 函数来等待此线程退出。</p><p>让我们看一个例子，主线程将创建另外一个线程。创建这个新线程后，主线程会在控制台上打印一些数据，然后等待新创建的线程退出。 </p><p>下面我们使用三种不同回调机制来实现上面的内容。</p><h3 id="使用函数指针创建线程"><a href="#使用函数指针创建线程" class="headerlink" title="使用函数指针创建线程"></a>使用函数指针创建线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread function Executing"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Display From MainThread"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj.join();    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Exit of Main function"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用函数对象创建线程"><a href="#使用函数对象创建线程" class="headerlink" title="使用函数对象创建线程"></a><strong>使用函数对象创建线程</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayThread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Display Thread Executing"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread threadObj( (DisplayThread()) );</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Display From Main Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Waiting For Thread to complete"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Exiting from Main Thread"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Lambda-函数创建线程"><a href="#使用-Lambda-函数创建线程" class="headerlink" title="使用 Lambda 函数创建线程"></a><strong>使用 Lambda 函数创建线程</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span></span></span><br><span class="line">                std::cout&lt;&lt;"Display Thread Executing"&lt;&lt;std::endl;</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Display From Main Thread"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Exiting from Main Thread"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何区分线程"><a href="#如何区分线程" class="headerlink" title="如何区分线程"></a>如何区分线程</h2><p>每个 std::thread 对象都有一个 ID，使用下面的函数可以获取：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::thread::get_id()</span><br></pre></td></tr></table></figure><p>获取当前线程的 ID：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::this_thread::get_id()</span><br></pre></td></tr></table></figure><p>如果 std::thread 对象没有和任何对象关联，则 get_id() 函数会返回默认构造的 std::thread::id 对象，即“非线程”。</p><p>std::thread::id 是一个对象，它也可以在控制台上进行比较和打印。让我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside Thread :: ID  = "</span>&lt;&lt;<span class="built_in">std</span>::this_thread::get_id()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj1</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj2</span><span class="params">(thread_function)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(threadObj1.get_id() != threadObj2.get_id())</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Both Threads have different IDs"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"From Main Thread :: ID of Thread 1 = "</span>&lt;&lt;threadObj1.get_id()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"From Main Thread :: ID of Thread 2 = "</span>&lt;&lt;threadObj2.get_id()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line"> </span><br><span class="line">    threadObj1.join();    </span><br><span class="line">    threadObj2.join();    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://thispointer.com/c-11-multithreading-part-1-three-different-ways-to-create-threads/&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++(2)--尽量用编译器取代预处理器</title>
    <link href="http://yoursite.com/2018/09/16/C++/Effective-C-2/"/>
    <id>http://yoursite.com/2018/09/16/C++/Effective-C-2/</id>
    <published>2018-09-16T13:37:36.000Z</published>
    <updated>2018-09-16T13:51:18.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基本摘抄自《Effective C++》 item2</p></blockquote><blockquote><p>尽量以 const， enum，inline 替换 #define</p></blockquote><h2 id="1-以常量替换-define"><a href="#1-以常量替换-define" class="headerlink" title="1 以常量替换 #define"></a>1 以常量替换 #define</h2><h3 id="1-1-定义常量"><a href="#1-1-定义常量" class="headerlink" title="1.1 定义常量"></a>1.1 定义常量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure><p>局限性：</p><ul><li>不会被编译器看见，或者在编译器开始处理源码之前被编译器移走</li><li>运用此常量获得编译错误信息时，可能带来困惑，因为错误信息会提到 1.653 而不是 ASPECT_RATIO</li><li>在记号式调试器中，由于使用名称没有进入记号表导致难以追踪</li></ul><p>解决：</p><blockquote><p>用常量替换宏</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span>;</span><br></pre></td></tr></table></figure><ul><li>作为语言常量，AspectRatio 肯定会被编译器看到，当然就会进入到记号表内</li><li>对浮点常量而言，使用常量可能比使用 #define 导致较小量的码，因为预处理“盲目地将名称 ASPECT_RATIO 替换为 1.653”可能导致目标码出现多份 1.653。</li></ul><p>下面说说两种特殊情况。</p><h3 id="1-2-定义常量指针"><a href="#1-2-定义常量指针" class="headerlink" title="1.2 定义常量指针"></a>1.2 定义常量指针</h3><p>由于常量定义式通常被放在头文件内（以便被不同的源码含入），因此有必要将指针（而不只是指针所指之物）声明为 const。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> authorName = <span class="string">"Longhai"</span>;</span><br></pre></td></tr></table></figure><p>详细见下一篇文章。<strong>string 对象通常比他的前辈 char *-base 更合适：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> authorName = <span class="string">"Longhai"</span>;</span><br></pre></td></tr></table></figure><h3 id="1-3-定义class专属常量"><a href="#1-3-定义class专属常量" class="headerlink" title="1.3 定义class专属常量"></a>1.3 定义class专属常量</h3><p>为了将常量的作用域（scope）限制于 class 内，必须让它成为 class 的一个成员（member）；而为确保此常量至多只有一份实体，必须让它成为一个 static 成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class GamePlayer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>;<span class="comment">//常量声明式</span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];<span class="comment">//使用该常量</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的是<code>NumTurns</code>的声明式而非定义式。</p><p>对于支持类内初始化的 C++ 编译器，这段代码可以编译通过。</p><p>但是较老的 C++ 编译器，可能不支持类内初始化，这样我们的静态常量，必须要在类外初始化。如下（在实现文件而非头文件中定义）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns;<span class="comment">//NumTurns的定义</span></span><br></pre></td></tr></table></figure><p>由于 class 常量已在声明时获得初值，因此定义时不可以再设初值。</p><p>更老的编译器可能不支持 static 成员在其声明式上获得初值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class GamePlayer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>;<span class="comment">//常量声明式</span></span><br><span class="line">    <span class="meta"># int scores[NumTurns];<span class="comment">//使用该常量</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns = <span class="number">5</span>;<span class="comment">//NumTurns的定义</span></span><br></pre></td></tr></table></figure><p>但是当在 class 编译期间需要一个 class 常量值，例如数组声明式（编译器坚持必须在编译期间知道数组的大小）。此时可以使用<code>the enum hack</code>方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class GamePlayer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;;<span class="comment">//令 NumTurns 成为 5 的一个记号名称</span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];<span class="comment">//使用该常量</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>enum hack</code>的行为某些方面比较像 #define 而不是 const，譬如取一个 const 的地址是合法的，但取一个 enum 的地址是不合法的，而取一个 #define 的地址通常（？为什么是通常）也不合法。</li><li>使用<code>enum hack</code>和 #define 一样不会导致 “不必要的内存分配”。 </li><li><code>enum hack</code>是模板元编程的一项基本技术，大量的代码在使用它。当你看到它时，你要认识它。 </li></ul><blockquote><p> 除非你处理的是主要具有历史意义的编译器(即1995年之前编写的编译器)，否则你不应该使用<code>enum hack</code>。尽管如此，知道它是什么样子还是值得的，因为在那些早期简单的时代，代码中遇到它并不少见。 </p></blockquote><h2 id="2-实现宏"><a href="#2-实现宏" class="headerlink" title="2 实现宏"></a>2 实现宏</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure><ul><li><p>无论何时，<strong>必须记住为宏中的所有实参加上小括号</strong></p></li><li><p>即使为所有实参加上小括号，也有可能有问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line">CALL_WITH_MAX(++a, b);<span class="comment">//a被累加2次</span></span><br><span class="line">CALL_WITH_MAX(++a, b+<span class="number">10</span>)<span class="comment">//a被累加1次</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>template inline 函数 – 同时获取宏带来的效率以及一般函数的所有可预料行为和类型安全性。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 由于我们不知道T是什么，所以采用 pass by reference-to-const. */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><ul><li><p>有了 consts、enums 和 inlines，我们对预处理器（<strong>尤其是 #define</strong>）的需求降低了，但并非完全消除。</p></li><li><p><code>#include</code>仍然是必需品，而<code>#ifdef / #ifndef</code>也继续扮演控制编译的重要角色。</p></li><li><p>对于单纯变量，最好以 const 对象或 enums 替换 #defines<br>对于形式函数的宏（macros），最好改用 inline 函数替换 #defines」</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文基本摘抄自《Effective C++》 item2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;尽量以 const， enum，inline 替换 #define&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++(1)--视C++为一个语言联邦</title>
    <link href="http://yoursite.com/2018/09/16/C++/Effective-C-1/"/>
    <id>http://yoursite.com/2018/09/16/C++/Effective-C-1/</id>
    <published>2018-09-16T11:36:29.000Z</published>
    <updated>2018-09-16T13:51:28.763Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基本摘抄自《Effective C++》 item1</p></blockquote><blockquote><p>将 C++ 视为一个由相关语言组成的联邦而非单一语言。<br>在其某个次语言（sublanguage）中，各种守则与通例都倾向简单、直观易懂、并且容易记住。<br>C++ <strong>4</strong>个次语言：</p></blockquote><ul><li><code>C</code>。说到底 C++ 还是以 C 为基础。许多时候 C++ 对于问题的解法其实不过就是较高级的 C 解法。</li><li><code>Object-Oriented C++</code>。即<code>C with class</code>所诉求的，对象、封装、集成、多态、virtual 函数等。</li><li><code>Template C++</code>。泛型编程部分（笔者注：这个就是自己不曾接触的部分）。</li><li><code>STL</code>。标准模板库，包含 4 个组件：算法、容器、迭代器以及函数。</li></ul><blockquote><p>从某个次语言切换到另一个，导致高效编程守则可能要求改变策略。<br>【例】<em>指针（值）还是引用传递问题？</em></p></blockquote><ul><li>内置类型（C-like）：<code>pass-by-value</code>通常比<code>pass-by-reference</code>高效</li><li>对象类型（<code>Object-Oriented C++</code>）：由于用户自定义构造函数和析构函数的存在，<code>pass-by-reference-to-const</code>往往更好</li><li><code>Template C++</code>：用引用，因为这个时候可能都不知道所处理的对象的类型。</li><li><code>STL</code>：迭代器和函数对象都是在 C 指针之上塑造出来的，所以对 STL 的迭代器和函数对象来说，旧式的 C <code>pass-by-value</code>守则再次适用。</li></ul><blockquote><p>作为从 C 语言转到 C++ 来说，这个次语言的概念确实对于理解整个 C++ 有一定的指导作用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文基本摘抄自《Effective C++》 item1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;将 C++ 视为一个由相关语言组成的联邦而非单一语言。&lt;br&gt;在其某个次语言（sublanguage）中，各种守则与通例都
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《参与感》小结</title>
    <link href="http://yoursite.com/2018/09/05/%E8%AF%BB%E4%B9%A6/%E3%80%8A%E5%8F%82%E4%B8%8E%E6%84%9F%E3%80%8B%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2018/09/05/读书/《参与感》小结/</id>
    <published>2018-09-04T23:53:54.000Z</published>
    <updated>2018-09-05T15:57:19.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学"><a href="#学" class="headerlink" title="学"></a>学</h2><p>书中主要内容及观点用思维导图概括如下：</p><p><img src="http://oi435vw1u.bkt.clouddn.com/%E5%8F%82%E4%B8%8E%E6%84%9F.png" alt="参与感"></p><h2 id="思"><a href="#思" class="headerlink" title="思"></a>思</h2><h3 id="小米的互联网思维"><a href="#小米的互联网思维" class="headerlink" title="小米的互联网思维"></a>小米的互联网思维</h3><ol><li>以用户为核心<ul><li>海底捞之所以火爆，是因为他们的服务确实好。单独的大厅用于等餐位（环境较好）、叠千纸鹤减免的小活动（客户可以从中获得小利益）、免费大麦茶及瓜子（打发无聊的等位时光）。【个人思考：在现今每个人都用手机打发无聊时光的时代，除了上述好的服务之外，等位的时候是否应该提供一个较好的“手机环境”，譬如快速的 WiFi，方便的充电等；还是秉承一个“去手机”理念，想法设法让大家接受吃饭的目的，是面对面社交？】</li></ul></li><li>口碑为王<ul><li>咨询了身边朋友唯一的小米粉，他成为小米忠实粉中的一员最主要的原因还是当年高性价比的爆品，再以书中多次提到的好用的 MIUI 系统加持。</li><li>《西虹市首富》只能算是一部及格作品，票房高有很大一个原因是开心麻花你的前面几部作品积攒的口碑，使观众习惯性的觉得会物超所值（当然作品不会太差）。与之对比的《我不是药神》，没有前作的口碑加成，只能纯粹靠观众的口口相传。这里做一个假设，假如原班人马（甚至是非原班人马）出《我不是药神2》，一开始的排片和上座率肯定惊人，假如作品一如既往的好，票房可期。</li></ul></li></ol><h3 id="小米崇尚的“参与感”到底是什么？"><a href="#小米崇尚的“参与感”到底是什么？" class="headerlink" title="小米崇尚的“参与感”到底是什么？"></a>小米崇尚的“参与感”到底是什么？</h3><ol><li><p>做爆品</p><ul><li>2018 年在智能手机市场整体下滑的情况下，华为手机依旧保持着不错的增长率，究其原因，有持续出爆款的因素。P20 的莱卡三摄、“吓死人的技术” GPU turbo、搭载麒麟 980（毕竟自研直逼世界一流水平）的新机magic 2即将上市，前两者是超乎客户预期的“爆品”，后者在华为手机已有口碑的情况下，可以预见也将是新一轮爆款的可能性非常大。</li></ul></li><li><p>互动方式的设计</p><p>互动方式必须有的原则：简单、收益、有趣、真实。</p><p>其中我思考比较多的是收益和真实。</p><ul><li>收益。其实无须多言，必须做到在客户得到优惠的前提下，自己也能从中获益。客户没有得到优惠，或者“性价比”，无法形成口碑；自己没有获益，等于自掘坟墓，无法长久。</li><li>真实。信任是一个很难量化的指标，而真实是获得信任的基础。我想所有人都比较喜欢和真诚实在的人打交道，至少不会因为说错一句话就会被人暗自“惦记”。马爸爸和阿里的六脉神剑，诚信乃其中一脉，支付宝的成功，最基础的应该归功于阿里建造了一套信用体系。也就是我相信，我付了钱，一定可以拿到我买的东西，虽然我对卖家的信息一无所知，并不知道对方是男是女，是善是恶。</li></ul></li></ol><h2 id="用"><a href="#用" class="headerlink" title="用"></a>用</h2><blockquote><p>【学为用】我们如何用互联网思维经营一家小区内普通的生活超市？</p></blockquote><p>我想，我们把经营超市当做一个产品，同样适用互联网思维。可以从下面几点来做，顺便指出其中使用的书中提到的背后逻辑。</p><ol><li><p>【用户体验】</p><p>对于超市来说，所有产品都是一些生活中需要的小物品，所以首先从产品的角度，所有超市的起点都是差不多的。那么使用基于“保证好用、努力好看”的原则，应该重点关注的就应该是“好看”的方向：</p><ul><li>必须保证超市内整体环境的<strong>整洁</strong>，给人一个好的第一印象。给顾客好印象需要日积月累的好感，但是坏印象只需要一次失望。</li><li>保证<strong>所有</strong>商品不积灰。同上的一个原理，也结合我们平常的购物经验，假如一家超市的商品上有积灰，会给人一种商品滞销、担心变质的心理暗示，这种情况下别说我们想要塑造的口碑，连这个客户可能都会永久的失去，毕竟和你竞争的同行很多，对于客户来说也就多走几步的关系。请关注重点词汇是所有，要做到这个真的需要费一些心力。</li><li>多站在<strong>顾客的角度</strong>思考问题。举一个简单的例子，假设超市内4G网络并不好，在现在大家平常支付都是掏出手机扫一扫的场景下，就非常有必要将WIFI及密码在比较醒目的点公示，并告诉大家4G网络不好，请提前连接WiFi。</li></ul></li><li><p>【口碑及强用户关系】</p><p>对于商品同质化严重的超市来说，要营造口碑是一个比较困难的事情。可以从如下几个角度切入：</p><ul><li>门店定期推出优惠活动，牺牲一点小利润培养用户的黏性和习惯。要相信，习惯一旦养成就会很难改变。</li><li>一般只有比较大型一点的超市才会设置会员制度，条件允许的情况下可以考虑会员系统。会员系统的作用就是要达到“用完即走”之后“想用即来”的效果。</li><li>对一个固定的商品，尽量使它成为附近人们购买的首选（即爆款），及时这款产品不产生利益。只有这样才能起到口口相传的口碑效应。</li><li>建立微信群，群内不定期发布优惠活动、团购活动等，增加用户活跃度。</li><li>微信群及门店的优惠活动都需要征询顾客的意见，让用户参与到优惠活动的制定中来（参与感），让用户得到切身需要的“性价比”。</li><li>重视“鲸鱼”客户，简单来说就是大客户。遇到一次购买比较多的商品（主要是烟酒）的顾客，尽量留下联系方式（最好是微信，用户关系最强），尽量进行更便利的服务，譬如送货上门等。</li></ul></li></ol><p>综合起来也有接近10来点值得注意的地方。想到这个案例是因为姐姐开了这样的一家小超市，希望后续可以策划更加详细的方案，帮助提升她的销售量，那就真的是学以致用了。</p><h2 id="感"><a href="#感" class="headerlink" title="感"></a>感</h2><p>《参与感》一书，虽然只听了一个大概系统内容，但是觉得还是可以深读一下。</p><p>互联网的口碑思维，在现在的商业环境应该说放到任何一个产品都是适用的，我们都应该学习并思考，假如有机会去实践，那就更加求之不得了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学&quot;&gt;&lt;a href=&quot;#学&quot; class=&quot;headerlink&quot; title=&quot;学&quot;&gt;&lt;/a&gt;学&lt;/h2&gt;&lt;p&gt;书中主要内容及观点用思维导图概括如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oi435vw1u.bkt.clouddn.com/%E5%
      
    
    </summary>
    
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>linux源码编译MySQL</title>
    <link href="http://yoursite.com/2018/09/01/MySQL/mysql_src_build/"/>
    <id>http://yoursite.com/2018/09/01/MySQL/mysql_src_build/</id>
    <published>2018-09-01T09:13:29.000Z</published>
    <updated>2019-01-06T14:52:32.110Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/home/longhai/install/mysql5.7 -DDOWNLOAD_BOOST=1 -DWITH_BOOST=/home/longhai/tools ..</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="MySQL内核" scheme="http://yoursite.com/tags/MySQL%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 8.0：新的无锁、可扩展的WAL设计</title>
    <link href="http://yoursite.com/2018/09/01/MySQL/%E6%96%B0%E7%9A%84%E6%97%A0%E9%94%81%E3%80%81%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84WAL%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/09/01/MySQL/新的无锁、可扩展的WAL设计/</id>
    <published>2018-09-01T09:13:29.000Z</published>
    <updated>2019-01-06T14:36:09.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>Write Ahead Log (WAL) 是数据库的重要组成部分之一。对数据文件的所有改动都被记录在 WAL (在 Innodb 中称为 redo log，即重做日志)。这样就允许将被修改的页刷新到磁盘的操作延时进行，并且能防止丢失数据。</p><p>在写入重做日志时，涉及许多用户线程的写入密集型工作负载的性能受到同步的限制。在具有多个CPU核心和快速存储设备(如现代SSD磁盘)的服务器上测试性能时，这一点尤为明显。</p><p><img src="/home/longhai/Nutstore/blog/redolog-old-1.png" alt="redolog-old-1"></p><p>我们需要一种新的设计来解决我们的客户和用户现在和将来可能面临的问题。调整旧设计以实现可扩展性不再是一种选择。新设计还必须灵活，以便我们将来可以扩展它来进行分片和并行写入。对于新的设计，我们希望确保它能与现有的 API 一起工作，最重要的是不要违反 InnoDB 的其他部分所依赖的 contract？？。在这些限制下，这是一项具有挑战性的任务。</p><p><img src="https://mysqlserverteam.com/wp-content/uploads/2018/05/redolog-new-2.png" alt="redolog-new-2"></p><p>重做日志可以被视为生产者/消费者持久队列。执行更新的用户线程可以被视为生产者，当 InnoDB 必须执行崩溃恢复时，恢复线程就是消费者。当服务器运行时，InnoDB 不会从重做日志中读取任何数据。</p><p><img src="/home/longhai/Nutstore/blog/redo-bufferpool-1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;Write Ahead Log (WAL) 是数据库的重要组成部分之一。对数据文件的所有改动都被记录在 WAL (在 I
      
    
    </summary>
    
    
      <category term="MySQL内核" scheme="http://yoursite.com/tags/MySQL%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>每天5分钟学MySQL内核(3) -- MySQL redo log 简介</title>
    <link href="http://yoursite.com/2018/09/01/MySQL/%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E5%AD%A6MySQL%E5%86%85%E6%A0%B83/"/>
    <id>http://yoursite.com/2018/09/01/MySQL/每天5分钟学MySQL内核3/</id>
    <published>2018-09-01T08:49:53.000Z</published>
    <updated>2018-09-01T09:12:22.248Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文采用创作共用署名2.5中国大陆版许可证（Creative Commons Attribution 2.5 China Mainland License）授权。</p></blockquote><p><a href="http://mysql.taobao.org/monthly/2017/09/07/" target="_blank" rel="noopener">[1] MySQL · 源码分析 · Innodb 引擎Redo日志存储格式简介</a></p><p><a href="https://blog.csdn.net/qiuyepiaoling/article/details/7838951" target="_blank" rel="noopener">[2] InnoDB存储引擎Log</a></p><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>任何对 Innodb 表的变动, redo log 都要记录对数据的修改，redo 日志就是记录要修改后的数据。redo 日志是保证事务一致性非常重要的手段，同时也可以使在 bufferpool 修改的数据不需要在事务提交时立刻写到磁盘上减少数据的 IO 从而提高整个系统的性能。这样的技术推迟了 bufferpool 页面的刷新，从而提升了数据库的吞吐，有效的降低了访问时延。带来的问题是额外的写 redo log 操作的开销。而为了保证数据的一致性，都要求 WAL（Write Ahead Logging）。而 redo 日志也不是直接写入文件，而是先写入 redo log buffer，而是批量写入日志。当需要将日志刷新到磁盘时（如事务提交），将许多日志一起写入磁盘。</p><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h2><ul><li>和 undo log 相反，redo log 记录的是<strong>新数据</strong>的备份。</li><li>在事务提交前，只要将 redo log 持久化即可，不需要将数据持久化。</li><li>当系统崩溃时，虽然数据没有持久化，但是 redo log 已经持久化。</li><li>系统可以根据 redo log 的内容，将所有数据恢复到最新的状态。 </li></ul><h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h2><p><strong>undo + redo 事务的简化过程</strong></p><p><img src="http://oi435vw1u.bkt.clouddn.com/undo+redo%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E6%8C%81%E4%B9%85%E6%80%A7%E7%A4%BA%E4%BE%8B.jpg" alt="undo+redo保证原子性与持久性示例"></p><ul><li>为了保证持久性，必须在事务提交前将 redo log 持久化</li><li>数据不需要在事务提交前写入磁盘，而是缓存在内存中</li><li>redo log 保证事务的持久性</li><li>undo log 保证事务的原子性</li><li>有一个隐含的特点，数据必须要晚于 redo log 写入持久存储</li></ul><h2 id="4-性能"><a href="#4-性能" class="headerlink" title="4. 性能"></a>4. 性能</h2><blockquote><p>undo + redo 的设计主要考虑的是提升 IO 性能。</p><p>虽说通过缓存数据，减少了写数据的 IO，但是却引入了新的IO，即写 redo log 的 IO。</p><p>如果 redo log 的 IO 性能不好，就不能起到提高性能的目的。</p></blockquote><p>为了保证 redo log 能够有比较好的 IO 性能，InnoDB 的 redo log 的设计有以下几个特点：</p><ul><li>尽量持 redo log 存储在一段连续的空间上。因此在系统第一次启动时就会将日志文件的空间完全分配，以顺序追加的方式记录 redo log，通过顺序 IO 来改善性能。</li><li>批量写入日志。日志并不是直接写入文件，而是先写入 redo log buffer。当需要将日志刷新到磁盘时 （如事务提交），将许多日志一起写入磁盘。</li><li>并发的事务共享 redo log 的存储空间，它们的 redo log 按语句的执行顺序，依次交替的记录在一起，以减少日志占用的空间。例如，redo log 中的记录内容可能是这样的：<ul><li>记录1:  &lt;trx1, insert …&gt;</li><li>记录2:  &lt;trx2, update …&gt;</li><li>记录3:  &lt;trx1, delete …&gt;</li><li>记录4:  &lt;trx3, update …&gt;</li><li>记录5:  &lt;trx2, insert …&gt;</li></ul></li><li>基于上一点，当一个事务将 redo log 写入磁盘时，也会将其他未提交的事务的日志写入磁盘。</li><li>redo log 上只进行顺序追加的操作，当一个事务需要回滚时，它的 redo log 记录也不会从 redo log 中删除掉。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文采用创作共用署名2.5中国大陆版许可证（Creative Commons Attribution 2.5 China Mainland License）授权。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://mysql
      
    
    </summary>
    
    
      <category term="MySQL内核" scheme="http://yoursite.com/tags/MySQL%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>每天5分钟学MySQL内核(2) -- undo log与AD</title>
    <link href="http://yoursite.com/2018/08/31/MySQL/%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E5%AD%A6MySQL%E5%86%85%E6%A0%B82/"/>
    <id>http://yoursite.com/2018/08/31/MySQL/每天5分钟学MySQL内核2/</id>
    <published>2018-08-30T22:54:10.000Z</published>
    <updated>2018-12-18T00:01:25.236Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文采用创作共用署名2.5中国大陆版许可证（Creative Commons Attribution 2.5 China Mainland License）授权。</p></blockquote><p><a href="https://blog.csdn.net/qiuyepiaoling/article/details/7838951" target="_blank" rel="noopener">[1] InnoDB存储引擎Log</a></p><h2 id="原子性与-undo-log"><a href="#原子性与-undo-log" class="headerlink" title="原子性与 undo log"></a>原子性与 undo log</h2><p>回顾事务的原子性：</p><blockquote><p> 事务中的所有操作，要么全部完成，要么不做任何操作。如果在执行的过程中出现了错误，要回滚（rollback）到事务开始前的状态，就像这个事务从来没有执行过。</p></blockquote><p>在 MySQL 中，使用 undo log 来实现事务的原子性（undo log 还用于实现多版本并发控制[ MVCC ]）。</p><h3 id="undo-简要原理"><a href="#undo-简要原理" class="headerlink" title="undo 简要原理"></a>undo 简要原理</h3><p>为了满足原子性，在操作任何数据之前，首先将数据备份到一个地方（即 undo log），然后进行数据的修改。如果出现了错误或者用户执行了 rollback 语句，数据库可以利用 undo log 中的备份数据恢复到事务开始之前的状态。</p><h2 id="持久性与-undo-log"><a href="#持久性与-undo-log" class="headerlink" title="持久性与 undo log"></a>持久性与 undo log</h2><p>undo log 可以用来辅助完成事务的持久性。</p><blockquote><p><strong>持久性：</strong>事务一旦完成，该事务对数据库所做的所有修改都会持久的保存到数据库中。为了保证持久性，数据库系统会将修改后的数据完全的记录到持久的存储上。 </p></blockquote><p><strong>用 undo Log 实现原子性和持久化的事务的简化过程</strong></p><p>假设有A、B两个数据，值分别为1，2。</p><p><img src="http://oi435vw1u.bkt.clouddn.com/undo%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E6%8C%81%E4%B9%85%E6%80%A7%E7%A4%BA%E4%BE%8B.jpg" alt="undo保证原子性与持久性示例"></p><p>这里有一个隐含的前提条件：数据都是先读到内存中，然后修改内存中的数据，最后将数据写回磁盘。</p><p>之所以能同时保证原子性和持久性，是因为以下特点:</p><p>A. 更新数据前记录 undo log。</p><p>B. 为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。</p><p>C. Undo log 必须先于数据持久化到磁盘。如果在 G, H 之间系统崩溃，undo log 是完整的，可以用来回滚事务。</p><p>D. 如果在 A-F 之间系统崩溃，因为数据没有持久化到磁盘，所以磁盘上的数据还是保持在事务开始前的状态。</p><p><strong>缺陷：</strong> 每个事务提交前将数据和 undo Log 写入磁盘，这样会导致大量的磁盘 IO，因此性能很低。如果能够将数据缓存一段时间，就能减少 IO 提高性能，但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即 Redo Log。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文采用创作共用署名2.5中国大陆版许可证（Creative Commons Attribution 2.5 China Mainland License）授权。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog
      
    
    </summary>
    
    
      <category term="MySQL内核" scheme="http://yoursite.com/tags/MySQL%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>每天5分钟学MySQL内核(1) -- ACID简介</title>
    <link href="http://yoursite.com/2018/08/26/MySQL/%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E5%AD%A6MySQL%E5%86%85%E6%A0%B81/"/>
    <id>http://yoursite.com/2018/08/26/MySQL/每天5分钟学MySQL内核1/</id>
    <published>2018-08-26T14:49:31.000Z</published>
    <updated>2018-08-30T23:04:33.110Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文采用创作共用署名2.5中国大陆版许可证（Creative Commons Attribution 2.5 China Mainland License）授权。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先，我们从数据库的 ACID 说起。</p><ul><li><p>原子性(Atomicity)</p><p>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。</p></li><li><p>一致性(Consistency)</p><p>一致性是指数据处于一种语义上的有意义且正确的状态。</p><p>一致性是对数据可见性的约束，保证在一个事务中的多次操作的数据中间状态对其他事务不可见的。</p><p>因为这些中间状态，是一个过渡状态，与事务的开始状态和事务的结束状态是不一致的。</p></li><li><p>隔离性(Isolation)</p><p>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</p></li><li><p>持久性(Durability)</p><p>指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。</p><p>即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</p></li></ul><p><strong>特性之间的关联</strong></p><ul><li>原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态。</li><li>在未提交读的隔离级别下，会造成脏读，这就是因为一个事务读到了另一个事务操作内部的数据。ACID中是的一致性描述的是一个最理想的事务应该怎样的，是一个强一致性状态，如果要做到这点，需要使用排它锁把事务排成一队，即 Serializable 的隔离级别，这样性能就大大降低了。现实是骨感的，所以使用隔离性的不同隔离级别来破坏一致性，以获取更好的性能。</li><li>最终一致 ~= 读未提交</li></ul><blockquote><p>事务可以不同程度的一致性：</p><ul><li>强一致性：读操作可以立即读到提交的更新操作。</li><li>弱一致性：提交的更新操作，不一定立即会被读操作读到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。</li><li>最终一致性：是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样的值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等。     </li></ul><p>其他一致性变体还有：</p><ul><li>单调一致性：如果一个进程已经读到一个值，那么后续不会读到更早的值。</li><li>会话一致性：保证客户端和服务器交互的会话过程中，读操作可以读到更新操作后的最新值。</li></ul></blockquote><p><a href="https://zh.wikipedia.org/zh-hans/ACID" target="_blank" rel="noopener">数据库ACID-维基</a></p><p><a href="http://geyifan.cn/2016/07/17/talk-about-transaction/" target="_blank" rel="noopener">一致性理解-博客</a></p><p><a href="https://www.zhihu.com/question/31346392" target="_blank" rel="noopener">一致性理解-知乎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文采用创作共用署名2.5中国大陆版许可证（Creative Commons Attribution 2.5 China Mainland License）授权。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言
      
    
    </summary>
    
    
      <category term="MySQL内核" scheme="http://yoursite.com/tags/MySQL%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>SpaceVim使用</title>
    <link href="http://yoursite.com/2018/08/08/vim/SpaceVim%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/08/vim/SpaceVim使用/</id>
    <published>2018-08-08T15:39:28.000Z</published>
    <updated>2018-08-26T03:43:20.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpaceVim简介"><a href="#SpaceVim简介" class="headerlink" title="SpaceVim简介"></a>SpaceVim简介</h1><blockquote><p>SpaceVim 是一个社区驱动的模块化 Vim IDE，以模块(layers)的方式组织管理插件以及相关配置， 为不同的语言开发量身定制了相关的开发模块，该模块提供代码自动补全， 语法检查、格式化、调试、REPL 等特性。用户仅需载入相关语言的模块即可得到一个开箱即用的Vim-IDE。</p><p>灵感来自于 Emacs 界首选配置 Spacemacs。</p></blockquote><h1 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在安装 SpaceVim 之前，确保已安装 <code>git</code> 和 <code>curl，</code>这两个工具用来 下载插件以及字体。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sLf https://spacevim.org/cn/install.sh | bash</span><br></pre></td></tr></table></figure><p>安装结束后，初次打开 <code>vim</code> 或者 <code>neovim</code> 时， SpaceVim 会<strong>自动</strong>下载并安装插件。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>SpaceVim 的默认配置文件为 <code>~/.SpaceVim.d/init.toml</code>，下面为一个简单的配置示例。 如果需要查阅更多 SpaceVim 配置相关的信息，请阅读 SpaceVim 用户文档。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个基础的 SpaceVim 配置示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有的 SpaceVim 选项都列在 [option] 之下</span></span><br><span class="line"><span class="section">[options]</span></span><br><span class="line">    <span class="comment"># 设置 SpaceVim 主题及背景，默认的主题是 gruvbox，如果你需要使用更</span></span><br><span class="line">    <span class="comment"># 多的主题，你可以载入 colorscheme 模块</span></span><br><span class="line">    colorscheme = "gruvbox"</span><br><span class="line">    <span class="comment"># 背景可以取值 "dark" 和 "light"</span></span><br><span class="line">    colorscheme_bg = "dark"</span><br><span class="line">    <span class="comment"># 启用/禁用终端真色，在目前大多数终端下都是支持真色的，当然也有</span></span><br><span class="line">    <span class="comment"># 一小部分终端不支持真色，如果你的 SpaceVim 颜色看上去比较怪异</span></span><br><span class="line">    <span class="comment"># 可以禁用终端真色，将下面的值设为 false</span></span><br><span class="line">    enable_guicolors = true</span><br><span class="line">    <span class="comment"># 设置状态栏上分割符号形状，如果字体安装失败，可以将值设为 "nil" 以</span></span><br><span class="line">    <span class="comment"># 禁用分割符号，默认为箭头 "arrow"</span></span><br><span class="line">    statusline_separator = "nil"</span><br><span class="line">    statusline_separator = "bar"</span><br><span class="line">    <span class="comment"># 设置顶部标签列表序号类型，有以下五种类型，分别是 0 - 4</span></span><br><span class="line">    <span class="comment"># 0: 1 ➛ ➊ </span></span><br><span class="line">    <span class="comment"># 1: 1 ➛ ➀</span></span><br><span class="line">    <span class="comment"># 2: 1 ➛ ⓵</span></span><br><span class="line">    <span class="comment"># 3: 1 ➛ ¹</span></span><br><span class="line">    <span class="comment"># 4: 1 ➛ 1</span></span><br><span class="line">    buffer_index_type = 4</span><br><span class="line">    <span class="comment"># 显示/隐藏顶部标签栏上文件类型图标，这一图标需要安装 nerd fonts，</span></span><br><span class="line">    <span class="comment"># 如果未能成功安装这一字体，可以隐藏图标</span></span><br><span class="line">    enable_tabline_filetype_icon = true</span><br><span class="line">    <span class="comment"># 是否在状态栏上显示当前模式，默认情况下，不显示 Normal/Insert 等</span></span><br><span class="line">    <span class="comment"># 字样，只以颜色区分当前模式</span></span><br><span class="line">    enable_statusline_display_mode = false</span><br><span class="line"></span><br><span class="line"><span class="comment"># SpaceVim 模块设置，主要包括启用/禁用模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用 autocomplete 模块, 启用模块时，可以列出一些模块选项，并赋值，</span></span><br><span class="line"><span class="comment"># 关于模块的选项，请阅读各个模块的文档</span></span><br><span class="line"><span class="section">[[layers]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"autocomplete"</span></span><br><span class="line"><span class="attr">auto-completion-return-key-behavior</span> = <span class="string">"complete"</span></span><br><span class="line"><span class="attr">auto-completion-tab-key-behavior</span> = <span class="string">"cycle"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用 shell 模块, 禁用模块时，需要加入 enable = false</span></span><br><span class="line"><span class="section">[[layers]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"shell"</span></span><br><span class="line"><span class="attr">enable</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加自定义插件</span></span><br><span class="line"><span class="section">[[custom_plugins]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"lilydjwg/colorizer"</span></span><br><span class="line"><span class="attr">merged</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="模块（layers）-快捷键"><a href="#模块（layers）-快捷键" class="headerlink" title="模块（layers）/快捷键"></a>模块（layers）/快捷键</h1><h2 id="模块使用"><a href="#模块使用" class="headerlink" title="模块使用"></a>模块使用</h2><ul><li><p>使能模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[layers]]</span><br><span class="line">name = "shell"</span><br><span class="line">default_position = "top"</span><br><span class="line">default_height = 30</span><br></pre></td></tr></table></figure></li><li><p>禁止模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[layers]]</span><br><span class="line">name = "shell"</span><br><span class="line">enable = false</span><br></pre></td></tr></table></figure></li></ul><p>以下介绍软件开发中经常使用的的模块及快捷键。</p><h2 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h2><p>在<code>.SpaceVim/autoload/SpaceVim/layers/tools.vim</code>文件中可以看到 tools 下有哪些插件。从作者关于 tools 这个模块的说明中可以得知，这些插件的快捷键都和插件的默认定义是一致的，并没有做任何更改。</p><p>下面选择几个非常有用的插件进行说明。</p><ul><li><p>MattesGroeger/vim-bookmarks – 标签相关</p><blockquote><p>在写代码是，需要经常转换行，这时候我们需要对要记住位置的行加入标签，然后进行跳转。</p></blockquote><p><img src="https://camo.githubusercontent.com/bc2bf1746e30c72d7ff5b79331231e8c388d068a/68747470733a2f2f7261772e6769746875622e636f6d2f4d617474657347726f656765722f76696d2d626f6f6b6d61726b732f6d61737465722f707265766965772e676966" alt=""></p></li></ul><table><thead><tr><th>Action</th><th>Shortcut</th><th>Command</th></tr></thead><tbody><tr><td>Add/remove bookmark at current line</td><td><code>mm</code></td><td><code>:BookmarkToggle</code></td></tr><tr><td>Add/edit/remove annotation at current line</td><td><code>mi</code></td><td><code>:BookmarkAnnotate &lt;TEXT&gt;</code></td></tr><tr><td>Jump to next bookmark in buffer</td><td><code>mn</code></td><td><code>:BookmarkNext</code></td></tr><tr><td>Jump to previous bookmark in buffer</td><td><code>mp</code></td><td><code>:BookmarkPrev</code></td></tr><tr><td>Show all bookmarks (toggle)</td><td><code>ma</code></td><td><code>:BookmarkShowAll</code></td></tr><tr><td>Clear bookmarks in current buffer only</td><td><code>mc</code></td><td><code>:BookmarkClear</code></td></tr><tr><td>Clear bookmarks in all buffers</td><td><code>mx</code></td><td><code>:BookmarkClearAll</code></td></tr><tr><td>Move up bookmark at current line</td><td><code>[count]mkk</code></td><td><code>:BookmarkMoveUp [&lt;COUNT&gt;]</code></td></tr><tr><td>Move down bookmark at current line</td><td><code>[count]mjj</code></td><td><code>:BookmarkMoveDown [&lt;COUNT&gt;]</code></td></tr><tr><td>Move bookmark at current line to another line</td><td><code>[count]mg</code></td><td><code>:BookmarkMoveToLine &lt;LINE&gt;</code></td></tr><tr><td>Save all bookmarks to a file</td><td></td><td><code>:BookmarkSave &lt;FILE_PATH&gt;</code></td></tr><tr><td>Load bookmarks from a file</td><td></td><td><code>:BookmarkLoad &lt;FILE_PATH&gt;</code></td></tr></tbody></table><h2 id="cscope"><a href="#cscope" class="headerlink" title="cscope"></a>cscope</h2><p>cscope 作用摘抄如下：</p><blockquote><ul><li>all references to a symbol</li><li>global definitions</li><li>functions called by a function</li><li>functions calling a function</li><li>text string</li><li>regular expression pattern</li><li>a file</li><li>files including a file</li></ul></blockquote><p>配置：</p><ol><li><p>安装cscope(建议源码安装)</p></li><li><p>源码根目录执行 cscope -Rbq(可以有更复杂的选项)</p></li><li><p>SpaceVim 配置文件中添加 cscope layer</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[layers]]</span><br><span class="line">name = 'cscope'</span><br></pre></td></tr></table></figure></li></ol><p>使用：</p><table><thead><tr><th>Key Binding</th><th>Description</th></tr></thead><tbody><tr><td><code>SPC m c =</code></td><td>Find assignments to this symbol</td></tr><tr><td><code>SPC m c i</code></td><td>Create cscope index</td></tr><tr><td><code>SPC m c c</code></td><td>Find functions called by this function</td></tr><tr><td><code>SPC m c C</code></td><td>Find functions calling this function</td></tr><tr><td><code>SPC m c d</code></td><td>find global definition of a symbol</td></tr><tr><td><code>SPC m c r</code></td><td>find references of a symbol</td></tr><tr><td><code>SPC m c f</code></td><td>find file</td></tr><tr><td><code>SPC m c F</code></td><td>find which files include a file</td></tr><tr><td><code>SPC m c e</code></td><td>search regular expression</td></tr><tr><td><code>SPC m c t</code></td><td>search text</td></tr></tbody></table><h2 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h2><p>GNU GLOBAL 作用官网摘抄如下：</p><blockquote><p>GNU GLOBAL is a source code tagging system that works the same way across diverse environments, such as Emacs editor, Vi editor, Less viewer, Bash shell, various web browsers, etc.</p><p>You can locate various objects, such as functions, macros, structs, classes, in your source files and move there easily. It is useful for hacking a large projects which contain many sub-directories, many <code>#ifdef</code> and many <code>main()</code>functions. It is similar to ctags or etags, but is different from them in the following two points:</p><ul><li>independence of any editor</li><li>capability to treat definition and reference</li></ul></blockquote><p>配置：</p><ol><li>安装 GNU GLOBAL (建议源码安装)</li><li>源码根目录执行 gtags (更复杂的选项请自行研究)</li><li>SpaceVim 配置文件中添加 gtags layer</li></ol><p>使用：</p><table><thead><tr><th>Key Binding</th><th>Description</th></tr></thead><tbody><tr><td><code>SPC m g c</code></td><td>create a tag database</td></tr><tr><td><code>SPC m g u</code></td><td>manually update tag database</td></tr><tr><td><code>SPC m g f</code></td><td>jump to a file in tag database</td></tr><tr><td><code>SPC m g d</code></td><td>find definitions</td></tr><tr><td><code>SPC m g r</code></td><td>find references</td></tr></tbody></table><h3 id="autocomplete"><a href="#autocomplete" class="headerlink" title="autocomplete"></a>autocomplete</h3><blockquote><p><a href="https://spacevim.org/layers/autocomplete/" target="_blank" rel="noopener">https://spacevim.org/layers/autocomplete/</a></p></blockquote><p>自动补全，写代码肯定是需要的。</p><p>示例配置如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable autocomplete layer</span></span><br><span class="line"><span class="section">[[layers]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">'autocomplete'</span></span><br><span class="line"><span class="attr">auto-completion-return-key-behavior</span> = <span class="string">"complete"</span></span><br><span class="line"><span class="attr">auto-completion-tab-key-behavior</span> = <span class="string">"smart"</span></span><br></pre></td></tr></table></figure><p>配置说明：</p><ul><li><code>auto-completion-return-key-behavior</code> – 回车键触发会触发如下动作：<ul><li><code>complete</code>: 使用当前选项补全</li><li><code>smart</code>: 使用当前选项补全，并展开代码段或者参数</li><li><code>nil</code>: 行为与enter键默认行为一致，会产生回车键的效果（换行）</li></ul></li><li><code>auto-completion-tab-key-behavior</code> – tab 键触发如下动作：<ul><li><code>smart</code> – 自动循环补全列表、展开代码块以及跳至下一个代码块的锚点（固定结构需要修改的地方）</li><li><code>cycle</code> – 自动循环补全列表</li><li><code>complete</code> – 插入当前选中的列表选项</li><li><code>nil</code> – 该行为和 Tab 的默认行为一致</li></ul></li></ul><h3 id="leaderf"><a href="#leaderf" class="headerlink" title="leaderf"></a>leaderf</h3><blockquote><p>搜索文件、函数列表、命令历史等</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[layers]]</span></span><br><span class="line">  name = "leaderf"</span><br></pre></td></tr></table></figure><p>最有用的应该就是模糊查找项目文件了：<code>ctrl-p</code> / <code>&lt;Leader&gt; f</code>[ <leader> 在 SpaceVim 中默认没有修改， 为 \ 键]</leader></p><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><blockquote><p>下文摘自官方文档</p></blockquote><h2 id="为什么选择-Toml-作为默认配置语言？"><a href="#为什么选择-Toml-作为默认配置语言？" class="headerlink" title="为什么选择 Toml 作为默认配置语言？"></a>为什么选择 Toml 作为默认配置语言？</h2><p>在往期的版本中，一直使用的 Vim 脚本作为配置文件，而 SpaceVim 读取配置文件的机制是 直接载入该脚本。Vim 在载入脚本时是边载入边执行的，这就意味着当你的配置文件中间部分 出现语法错误时，并不能阻止前半部分配置被载入，排错时非常有影响。</p><p>因此我们选择了另外一种更加健壮的语言来配置 SpaceVim，SpaceVim 会完整读取该配置文件， 如果文件中间出现语法错误，导致解析失败。那么该配置会被完全舍弃，而使用 SpaceVim 的 默认配置，这就大大降低了因配置文件错误导致 SpaceVim 运行出错的可能性。</p><p>在配置文件格式选择时，我们在 json、yaml、xml、toml 这四中文件格式之间也做了比较。</p><ol><li>yaml 依赖缩进，配置转移时易出错，不与考虑</li><li>xml 缺少 vim 解析库， 不与考虑</li><li>json 时一个比较好的配置信息传输格式，并且 Vim 有一个解析的函数，但是 json 格式 不支持注释，手写编辑时，阅读性太差。</li></ol><p>因此，我们选择了 Toml 作为默认的配置格式，并且解析后，缓存为 json 文件。SpaceVim 在启动时直接读取缓存 json 文件，效率更高。</p><h2 id="为什么-SpaceVim-颜色主题和官网不一致？"><a href="#为什么-SpaceVim-颜色主题和官网不一致？" class="headerlink" title="为什么 SpaceVim 颜色主题和官网不一致？"></a>为什么 SpaceVim 颜色主题和官网不一致？</h2><p>因为在 SpaceVim 中，默认情况下是启用了终端真色，因此你需要确保你的终端支持真色。 但是并不是每种终端默认都支持真色的。因此，当你的终端不支持真色时， 你可以在配置文件里面禁用真色支持：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable_guicolors = false</span><br></pre></td></tr></table></figure><h2 id="如何增加自定义快捷键？"><a href="#如何增加自定义快捷键？" class="headerlink" title="如何增加自定义快捷键？"></a>如何增加自定义快捷键？</h2><p>使用 Toml 作为默认配置文件后，无法在配置文件里面直接添加 Vim 快捷键， 这点让很多用户感到困惑。实际上，SpaceVim 支持指定载入配置时需要调用的函数。</p><p>比如，我需要加入这样一个快捷键，使用 <code>&lt;Leader&gt; w</code> 来保存当前文件。那么， 我需要修改配置文件，并指定一个载入时需要调用的方法：</p><p>修改 <code>~/.SpaceVim.d/init.toml</code>，加入 <code>bootstrap_before</code> 选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[options]</span><br><span class="line">  bootstrap_before = &quot;myspacevim#init&quot;</span><br></pre></td></tr></table></figure><p>添加文件 <code>~/.SpaceVim.d/autoload/myspacevim.vim</code>, 并加入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function! myspacevim#init() abort</span><br><span class="line">  nnoremap &lt;Leader&gt;w :w&lt;cr&gt;</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpaceVim简介&quot;&gt;&lt;a href=&quot;#SpaceVim简介&quot; class=&quot;headerlink&quot; title=&quot;SpaceVim简介&quot;&gt;&lt;/a&gt;SpaceVim简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;SpaceVim 是一个社区驱动的模块化 Vim 
      
    
    </summary>
    
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 环境搭建</title>
    <link href="http://yoursite.com/2018/08/01/vim/Ubuntu%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/08/01/vim/Ubuntu环境搭建/</id>
    <published>2018-08-01T15:25:31.000Z</published>
    <updated>2018-08-11T12:39:49.394Z</updated>
    
    <content type="html"><![CDATA[<p>以下是我每次安装 ubuntu 都会搭建的开发/娱乐环境，请读者参考。下面的内容比较精简，我主要是点出有这个东西，并且是我自己必备的东西，肯定也是蛮好用的，具体是什么，怎么用，网上已经有很多比我写的很好的轮子了，我就不重造了。另外如果你有好的推荐，也请告知我，我是工具/效率控，也想继续提升。</p><p><img src="http://oi435vw1u.bkt.clouddn.com/ubuntu.png" alt="ubuntu环境搭建"></p><h2 id="1-编辑器"><a href="#1-编辑器" class="headerlink" title="1. 编辑器"></a>1. 编辑器</h2><ul><li><p>neovim（更快的vim ?）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ninja-build gettext libtool libtool-bin autoconf automake cmake g++ pkg-config unzip</span><br><span class="line">git clone https://github.com/neovim/neovim.git</span><br><span class="line">make -j8</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">## 我最后使用的是 apt 安装，现在住的地方（颠沛流离啊）网络实在不行，会卡在某些下载处。</span><br><span class="line">sudo apt-get install neovim</span><br><span class="line">sudo apt-get install xclip</span><br><span class="line">sudo apt-get install xclip</span><br><span class="line">pip install neovim</span><br><span class="line">pip3 install neovim</span><br></pre></td></tr></table></figure></li><li><p>SpaceVim（neovim / vim 强大配置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sLf https://spacevim.org/install.sh | bash</span><br></pre></td></tr></table></figure><p>关于 SpaceVim 要说的很多，后续专门成文说明。</p></li><li><p>tmux（分屏工具）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y install libevent-dev libncurses-dev</span><br><span class="line">git clone https://github.com/tmux/tmux.git</span><br><span class="line">cd tmux</span><br><span class="line">sh autogen.sh</span><br><span class="line">./configure &amp;&amp; make</span><br><span class="line"></span><br><span class="line"># 去除&lt;200b&gt;[我从《tmux 2 Productive Mouse-Free Development》这本书拷贝配置的时候遇到这个问题]</span><br><span class="line">sed -i &apos;s/\xe2\x80\x8b//g&apos; inputfile</span><br></pre></td></tr></table></figure></li><li><p>typora</p><p>markdown写作神器，跨各种平台，推荐！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># optional, but recommended</span><br><span class="line"># sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span><br><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv BA300B7755AFCFAE</span><br><span class="line"># add Typora&apos;s repository</span><br><span class="line">sudo add-apt-repository &apos;deb https://typora.io/linux ./&apos;</span><br><span class="line">sudo apt-get update</span><br><span class="line"># install typora</span><br><span class="line">sudo apt-get install typora</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-命令行"><a href="#2-命令行" class="headerlink" title="2. 命令行"></a>2. 命令行</h2><ul><li><p>zsh + oh_my_zsh（zsh 及配置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y install zsh</span><br><span class="line">sudo apt -y install curl</span><br><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure></li><li><p>fzf（模糊搜索历史命令、文件等）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf</span><br><span class="line">~/.fzf/install</span><br></pre></td></tr></table></figure></li><li><p>z（快速跳转目录）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/rupa/z.git</span><br><span class="line">echo &quot;. ~/tools/z/z.sh&quot; &gt;&gt; ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></li><li><p>ag（快速搜索）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y automake pkg-config libpcre3-dev zlib1g-dev liblzma-dev</span><br><span class="line">cd the_silver_searcher &amp;&amp; ./build.sh</span><br><span class="line">make -j8 &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-工具"><a href="#3-工具" class="headerlink" title="3. 工具"></a><strong>3. 工具</strong></h2><ul><li><p>搜狗输入法</p></li><li><p>VNote（笔记软件）</p><p>本来有道云笔记很好用，可是就是没有 linux 版本…</p><p>VNote 跨三种平台，并且支持 vi 模式。</p><p>结合下面的坚果云，可以实现同步。</p></li><li><p>坚果云（同步文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.jianguoyun.com/static/exe/installer/ubuntu/nautilus_nutstore_amd64.deb</span><br><span class="line">sudo apt-get install gdebi</span><br><span class="line">sudo gdebi nautilus_nutstore_amd64.deb</span><br><span class="line"></span><br><span class="line"># SSL 连接错误解决方案</span><br><span class="line">sudo apt purge &apos;openjdk-*&apos;</span><br><span class="line">[ -d /usr/lib/jvm ] &amp;&amp; sudo mv /usr/lib/jvm /usr/lib/jvm-backup</span><br><span class="line">sudo apt install -y openjdk-8-jre</span><br></pre></td></tr></table></figure></li><li><p>Xmind-ZEN</p><p>思维导图，免费版就够用了，不过导出图片就有水印，土豪请支持正版。</p><p>效果请看本文第一图。</p></li></ul><h2 id="4-科学上网"><a href="#4-科学上网" class="headerlink" title="4. 科学上网"></a>4. 科学上网</h2><ul><li><p>vps</p><p>科学上网可以选择购买市面上的 vpn，简单方便，不过随时面临倒闭的风险，毕竟是国家重点照顾的领域。我相信在看这篇文章的朋友大部分是程序员，至少应该是 IT 从业者，所以我觉得应该自己购买 vps 搭梯子，多折腾。弄好了</p></li><li><p>安装Shadowsocks-qt5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/shadowsocks/shadowsocks-qt5/releases/download/v3.0.1/Shadowsocks-Qt5-3.0.1-x86_64.AppImage</span><br><span class="line">vpsIP</span><br><span class="line">ss端口</span><br><span class="line">ss密码</span><br><span class="line">aes-256-cfb（ss加密方式）</span><br><span class="line">1080</span><br></pre></td></tr></table></figure></li><li><p>代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pip</span><br><span class="line">sudo pip install genpac</span><br><span class="line">genpac --pac-proxy &quot;127.0.0.1:1080&quot; --output=&quot;autoproxy.pac&quot;</span><br><span class="line">Network proxy 设置: file:///home/longhai/autoproxy.pac</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-博客"><a href="#5-博客" class="headerlink" title="5. 博客"></a>5. 博客</h2><ul><li><p>hexo</p><p>简单，可定制，需折腾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install npm</span><br><span class="line">sudo npm install hexo-cli -g</span><br><span class="line">sudo npm install hexo -g</span><br><span class="line"></span><br><span class="line"># github 上创建名为 username.github.io 的空库（username为github账户）</span><br><span class="line">git clone https://github.com/longhaiqwe/longhaiqwe.github.io.git</span><br><span class="line"></span><br><span class="line">mkdir -p ~/blog/hexo</span><br><span class="line">cd hexo</span><br><span class="line">hexo init</span><br><span class="line">npm install hexo-generator-index –save </span><br><span class="line">npm install hexo-generator-index --save </span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag  --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-stylus</span><br><span class="line">npm install hexo-renderer-stylus --save</span><br><span class="line">npm install hexo-generator-feed </span><br><span class="line">npm install hexo-generator-feed  --save</span><br><span class="line">npm install hexo-generator-sitemap  --save</span><br><span class="line"></span><br><span class="line">## 或者可以使用如下一条命令解决：</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">## 并且好像上面那一条语句也可以不用执行～</span><br><span class="line"></span><br><span class="line">## Quick Start</span><br><span class="line">hexo new &quot;My New Post&quot;</span><br><span class="line">hexo server</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-持续更新"><a href="#6-持续更新" class="headerlink" title="6. 持续更新"></a>6. 持续更新</h2><ul><li><p>ubuntu  gnome-terminal 选中即复制</p><p>安装clipit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install clipit</span><br></pre></td></tr></table></figure><p>配置：打开clipit，在任务栏cliplt图标 右键–&gt;prefrences，勾选 User Primary(Selection) 和 Synchronize clipboards即可。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是我每次安装 ubuntu 都会搭建的开发/娱乐环境，请读者参考。下面的内容比较精简，我主要是点出有这个东西，并且是我自己必备的东西，肯定也是蛮好用的，具体是什么，怎么用，网上已经有很多比我写的很好的轮子了，我就不重造了。另外如果你有好的推荐，也请告知我，我是工具/效率
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL中PGDLLIMPORT的使用</title>
    <link href="http://yoursite.com/2017/05/19/PostgreSQL/kernel/PostgreSQL%E4%B8%ADPGDLLIMPORT%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/05/19/PostgreSQL/kernel/PostgreSQL中PGDLLIMPORT的使用/</id>
    <published>2017-05-19T08:38:15.000Z</published>
    <updated>2018-12-19T23:16:28.882Z</updated>
    
    <content type="html"><![CDATA[<p>在PostgreSQL源码中，随处可见PGDLLIMPORT的使用，笔者曾经使用过，当时对其含义是<br>没有太多认知的。经过一番研究，多少有点了解，本着分享原则，本文尝试解释其含义。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>src/include/port/win32.h</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef BUILDING_DLL</span><br><span class="line">#define PGDLLIMPORT __declspec (dllexport)</span><br><span class="line">#else                           /* not BUILDING_DLL */</span><br><span class="line">#define PGDLLIMPORT __declspec (dllimport)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>首先，PGDLLIMPORT在非windows平台，是不做任何事情的。</p><p>在Windows平台, PGDLLIMPORT的含义根据在编译PostgreSQL主程序还是扩展插件，有不同的含义：</p><ul><li><p>假设BUILDING_DLL被定义，PGDLLIMPORT被定义为__declspec(dllexport)，即会从 PostgreSQL的server二进制文件中导出符号（变量、函数）</p></li><li><p>假如BUILDING_DLL未被定义，PGDLLIMPORT被定义为__declspec(dllimport)，表明 此符号是被导入的，即引用自PostgreSQL。</p></li></ul><p>需要注意的是，仅仅在编译posres.exe的时候才会定义BUILDING_DLL。</p><p>所以在postgres主程序中使用，代表输出符号；在插件代码中使用，代表导入符号。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>结合PostgreSQL中的hook使用给出举例说明。</p><p><a href="http://www.longhaiqwe.com/2016/06/24/src/PostgreSQL%E4%B8%ADhook%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">PostgreSQL中hook使用</a></p><p>在上面这篇文章中，在src/include/libpq/auth.h中对ClientAuthentication_hook的定义使用了PGDLLIMPORT, 代表导出此hook；</p><p>在我新增的插件中（my_client_auth.c）使用：#include “libpq/auth.h”，说明此hook定义是从其他地方导入。</p><p>之所以需要使用PGDLLIMPORT，涉及到windows中动态库的链接个工作机制（<a href="https://msdn.microsoft.com/en-us/library/a90k134d.aspx" target="_blank" rel="noopener">how DLL linkage works on win32/PE</a>）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>在windows下，假如在extension中需要用到postgres主程序中的变量或函数，必须使用PGDLLIMPORT声明，并且在扩展中也用PGDLLIMPORT声明。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在PostgreSQL源码中，随处可见PGDLLIMPORT的使用，笔者曾经使用过，当时对其含义是&lt;br&gt;没有太多认知的。经过一番研究，多少有点了解，本着分享原则，本文尝试解释其含义。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="PostgreSQL" scheme="http://yoursite.com/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>详解offsetof与container_of宏.md</title>
    <link href="http://yoursite.com/2017/05/16/C/%E8%AF%A6%E8%A7%A3offsetof%E4%B8%8Econtainer-of%E5%AE%8F/"/>
    <id>http://yoursite.com/2017/05/16/C/详解offsetof与container-of宏/</id>
    <published>2017-05-16T01:51:42.000Z</published>
    <updated>2018-12-19T23:11:56.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于offsetof与container_of宏,以前见过,同事也分享过,但是一直没有太过深究.</p><p>这次面试,被问到之后并没有很好的对答如流,回来也好好总结了一下,也试着分享一下.</p><h2 id="offsetof宏"><a href="#offsetof宏" class="headerlink" title="offsetof宏"></a>offsetof宏</h2><p>定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define offsetof(TYPE, MEMBER) (size_t)&amp;(((TYPE*)0)-&gt;MEMBER)</span><br></pre></td></tr></table></figure><p>抽丝剥茧:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(TYPE *)0 //将地址0强转为TYPE类型的指针</span><br><span class="line">((TYPE *)0)-&gt;MEMBER //引用TYPE类型的MEMBER成员</span><br><span class="line">&amp;(((TYPE *)0)-&gt;MEMBER) //获取MEMBER成员你的地址</span><br><span class="line">(size_t)&amp;(((TYPE *)0)-&gt;MEMBER) //上述地址转化为size_t类型</span><br></pre></td></tr></table></figure></p><p>总结:</p><blockquote><p>获取MEMBER变量相对于结构体TYPE的偏移量</p></blockquote><h2 id="container-of宏"><a href="#container-of宏" class="headerlink" title="container_of宏"></a>container_of宏</h2><p>定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define container_of(ptr, TYPE, MEMBER) (&#123;\</span><br><span class="line">    const typeof(((TYPE *)0)-&gt;MEMBER) *__ptr = (ptr);\</span><br><span class="line">    (TYPE *)((char *)__ptr - offsetof(TYPE, MEMBER));&#125;)</span><br></pre></td></tr></table></figure></p><p>抽丝剥茧:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">((TYPE *)0)-&gt;MEMBER //引用TYPE类型的MEMBER成员</span><br><span class="line">typeof(((TYPE *)0)-&gt;MEMBER) //获取MENBER的类型</span><br><span class="line">const typeof(((TYPE *)0)-&gt;MEMBER) *__ptr = (ptr) //ptr保存到上述类型的指针__ptr中</span><br><span class="line">(TYPE *)((char *)__ptr - offsetof(TYPE, MEMBER)) //通过上述地址减去偏移量得到type的起始地址</span><br></pre></td></tr></table></figure></p><p>总结:</p><blockquote><p>通过结构体某个成员的地址得到整个结构体的起始地址</p></blockquote><p>说明:</p><blockquote><p>使用__ptr的目的是在编译期间进行类型检测(第一句，赋值时如果类型不匹配会报告警)，<br>保证传入的成员地址与成员类型是匹配的，而在运行期间则和忽略中间变量__ptr是一样的。</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123; \</span></span><br><span class="line">    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \</span><br><span class="line">    (type *)( (<span class="keyword">char</span> *)__mptr - offsetof(type,member) );&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The sutdent structure definition */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">char</span> phone_num[<span class="number">16</span>];</span><br><span class="line">&#125; STUDENT, *STUDENT_PTR;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_id</span><span class="params">(<span class="keyword">char</span> *phone_numP)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STUDENT_PTR stdP = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the structure pointer by giving the mmeber </span></span><br><span class="line"><span class="comment">     * address of 'phone_numP'.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    stdP = container_of(phone_numP, STUDENT, phone_num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Student: %s, His ID: %d\n"</span>, stdP-&gt;name, stdP-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STUDENT_PTR stdP = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((stdP = (STUDENT_PTR)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STUDENT))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"malloc error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* assign the value for each member */</span></span><br><span class="line">    <span class="built_in">strncpy</span>(stdP-&gt;name, <span class="string">"Longhai"</span>, <span class="keyword">sizeof</span>(stdP-&gt;name));</span><br><span class="line">    stdP-&gt;id = <span class="number">123456</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(stdP-&gt;addr, <span class="string">"Road 1"</span>, <span class="keyword">sizeof</span>(stdP-&gt;addr));</span><br><span class="line">    <span class="built_in">strncpy</span>(stdP-&gt;phone_num, <span class="string">"11111111"</span>, <span class="keyword">sizeof</span>(stdP-&gt;phone_num));</span><br><span class="line"></span><br><span class="line">    print_id(stdP-&gt;phone_num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;关于offsetof与container_of宏,以前见过,同事也分享过,但是一直没有太过深究.&lt;/p&gt;
&lt;p&gt;这次面试,被问到之后并没有很
      
    
    </summary>
    
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
</feed>

---
title: 创建线程的三种方式
date: 2018-10-17 23:01:00
tags: C++
---

> 

> 本文翻译自[Three Different ways to Create Threads](https://thispointer.com/c-11-multithreading-part-1-three-different-ways-to-create-threads/)

本篇介绍如何在 C++11 中使用 std::thread 来创建线程。

## C++11 线程库介绍

传统的C++只支持单线程编程。新的 C++ 标准 (即 C++11 或 C++0x) 于 2011 年发布。 C++11 中引入了一个新的线程库。

**编译器要求：**  

**Linux:** gcc 4.8.1 （完整的并发支持）
**Windows:** Visual Studio 2012 and MingW

**Linux 下如何编译：** `g++ –std=c++11 sample.cpp -lpthread`

## C++11 线程创建

每一个 C++11 程序都包含一个主线程即 main() 函数。 在 C++11 中我们可以通过创建 std::thread 对象来创建新的线程。

每个 std::thread 对象都可以与一个线程相关联。 

需要引用的头文件：

```c++
#include <thread>
```

### std::thread的构造函数中接受什么参数？

我们可以给 std::thread 对象添加函数，这个回调函数将在这个新线程启动时执行。这些回调可以是：

1.) 函数指针
2.) 函数对象
3.) Lambda 函数

创建 thread 对象：

```c++
std::thread thObj(<CALLBACK>);
```

新线程将在创建新对象后立即启动，并将并行地执行（当参数）传递给线程的回调函数。 

此外，任何线程都可以通过调用某线程对象上的 join( ) 函数来等待此线程退出。

让我们看一个例子，主线程将创建另外一个线程。创建这个新线程后，主线程会在控制台上打印一些数据，然后等待新创建的线程退出。 

下面我们使用三种不同回调机制来实现上面的内容。

### 使用函数指针创建线程

```c++
#include <thread>
 
void thread_function()
{
    for(int i = 0; i < 10000; i++);
        std::cout<<"thread function Executing"<<std::endl;
}
 
int main()  
{
    
    std::thread threadObj(thread_function);
    for(int i = 0; i < 10000; i++);
        std::cout<<"Display From MainThread"<<std::endl;
    threadObj.join();    
    std::cout<<"Exit of Main function"<<std::endl;
    return 0;
}
```

### **使用函数对象创建线程**

```c++
#include <iostream>
#include <thread>
class DisplayThread
{
public:
    void operator()()     
    {
        for(int i = 0; i < 10000; i++)
            std::cout<<"Display Thread Executing"<<std::endl;
    }
};
 
int main()  
{
    std::thread threadObj( (DisplayThread()) );
    for(int i = 0; i < 10000; i++)
        std::cout<<"Display From Main Thread "<<std::endl;
    std::cout<<"Waiting For Thread to complete"<<std::endl;
    threadObj.join();
    std::cout<<"Exiting from Main Thread"<<std::endl;
    return 0;
}
```

### **使用 Lambda 函数创建线程**

```c++
#include <iostream>
#include <thread>
int main()  
{
    int x = 9;
    std::thread threadObj([]{
            for(int i = 0; i < 10000; i++)
                std::cout<<"Display Thread Executing"<<std::endl;
            });
            
    for(int i = 0; i < 10000; i++)
        std::cout<<"Display From Main Thread"<<std::endl;
        
    threadObj.join();
    std::cout<<"Exiting from Main Thread"<<std::endl;
    return 0;
}
```

## 如何区分线程

每个 std::thread 对象都有一个 ID，使用下面的函数可以获取：

```c++
std::thread::get_id()
```

获取当前线程的 ID：

```c++
std::this_thread::get_id()
```

如果 std::thread 对象没有和任何对象关联，则 get_id() 函数会返回默认构造的 std::thread::id 对象，即“非线程”。

std::thread::id 是一个对象，它也可以在控制台上进行比较和打印。让我们来看一个例子：

```C++
#include <iostream>
#include <thread>
void thread_function()
{
    std::cout<<"Inside Thread :: ID  = "<<std::this_thread::get_id()<<std::endl;    
}
int main()  
{
    std::thread threadObj1(thread_function);
    std::thread threadObj2(thread_function);
 
    if(threadObj1.get_id() != threadObj2.get_id())
        std::cout<<"Both Threads have different IDs"<<std::endl;
 
    std::cout<<"From Main Thread :: ID of Thread 1 = "<<threadObj1.get_id()<<std::endl;    
    std::cout<<"From Main Thread :: ID of Thread 2 = "<<threadObj2.get_id()<<std::endl;    
 
    threadObj1.join();    
    threadObj2.join();    
    return 0;
}
```
---
title: C++11多线程 -【3】传参给线程
date: 2018-11-13 23:01:49
tags: C++
---

> 本文翻译自 [C++11 Multithreading – Part 3: Carefully Pass Arguments to Threads](https://thispointer.com/c11-multithreading-part-3-carefully-pass-arguments-to-threads/)

要将参数传递给线程关联的可调用对象或函数，只需将参数传递给 std::thread 构造函数。

默认情况下，所有参数都被复制到新线程的内部存储中。

## 向 C++ 11 中的 std::thread 传递简单参数

如下是一个简单示例：

```c++
#include <iostream>
#include <string>
#include <thread>
void threadCallback(int x, std::string str)
{
    std::cout<<"Passed Number = "<<x<<std::endl;
    std::cout<<"Passed String = "<<str<<std::endl;
}
int main()  
{
    int x = 10;
    std::string str = "Sample String";
    std::thread threadObj(threadCallback, x, str);
    threadObj.join();
    return 0;
}
```
## 如何不将参数传递给 C++ 11 中的线程

> 译者注：这里的标题感觉和下文的内容不是很符合，“什么情况不能将参数传递给线程”更为合适？

不要将变量的地址从本地堆栈传递给线程的回调函数。因为线程 1 中的局部变量可能超出范围，但是线程 2 仍然试图通过其地址访问它。

在这种情况下，访问无效地址会导致意外行为。

请看如下示例：

```c++
#include <iostream>
#include <thread>
void newThreadCallback(int * p)
{
    std::cout<<"Inside Thread :  "" : p = "<<p<<std::endl;
    std::chrono::milliseconds dura( 1000 );
    std::this_thread::sleep_for( dura );
    *p = 19;
}
void startNewThread()
{
    int i = 10;
    std::cout<<"Inside Main Thread :  "" : i = "<<i<<std::endl;
    std::thread t(newThreadCallback,&i);
    t.detach();
    std::cout<<"Inside Main Thread :  "" : i = "<<i<<std::endl;
}
int main()
{
    startNewThread();
    std::chrono::milliseconds dura( 2000 );
    std::this_thread::sleep_for( dura );
    return 0;
}
```

同样，将指向堆上内存的指针传递给线程时也要小心。因为在新线程试图访问内存之前，一些线程可能会删除该内存。

在这种情况下，访问无效地址会导致意外行为。

请看如下示例：

```c++
#include <iostream>
#include <thread>
void newThreadCallback(int * p)
{
    std::cout<<"Inside Thread :  "" : p = "<<p<<std::endl;
    std::chrono::milliseconds dura( 1000 );
    std::this_thread::sleep_for( dura );
    *p = 19;
}
void startNewThread()
{
    int * p = new int();
    *p = 10;
    std::cout<<"Inside Main Thread :  "" : *p = "<<*p<<std::endl;
    std::thread t(newThreadCallback,p);
    t.detach();
    delete p;
    p = NULL;
}
int main()
{
    startNewThread();
    std::chrono::milliseconds dura( 2000 );
    std::this_thread::sleep_for( dura );
    return 0;
}
```

## 如何在 C++ 11 中将引用传递给 std::thread

因为参数被复制到新线程堆栈，所以，如果你需要以普通方式传递引用，如下例：

```c++
#include <iostream>
#include <thread>
void threadCallback(int const & x)
{
    int & y = const_cast<int &>(x);
    y++;
    std::cout<<"Inside Thread x = "<<x<<std::endl;
}
int main()
{
    int x = 9;
    std::cout<<"In Main Thread : Before Thread Start x = "<<x<<std::endl;
    std::thread threadObj(threadCallback, x);
    threadObj.join();
    std::cout<<"In Main Thread : After Thread Joins x = "<<x<<std::endl;
    return 0;
}
```

输出如下：

```shell
In Main Thread : Before Thread Start x = 9
Inside Thread x = 10
In Main Thread : After Thread Joins x = 9
```

即使`threadCallback`接受引用作为参数，但进行了更改之后，在线程之外也不可见。

这是因为线程函数`threadCallback`中的 x 是在新线程堆栈中复制的临时值的引用。

怎样修复上面的问题？

使用`std::ref()`，如下：

```c++
#include <iostream>
#include <thread>
void threadCallback(int const & x)
{
    int & y = const_cast<int &>(x);
    y++;
    std::cout<<"Inside Thread x = "<<x<<std::endl;
}
int main()
{
    int x = 9;
    std::cout<<"In Main Thread : Before Thread Start x = "<<x<<std::endl;
    std::thread threadObj(threadCallback,std::ref(x));
    threadObj.join();
    std::cout<<"In Main Thread : After Thread Joins x = "<<x<<std::endl;
    return 0;
}
```

输出如下：

```shell
In Main Thread : Before Thread Start x = 9
Inside Thread x = 10
In Main Thread : After Thread Joins x = 10
```

## 将指向类成员函数的指针作为线程函数

将指向成员函数的指针作为回调函数传递，将指向对象的指针作为第二个参数传递。

看下面的示例：

```c++
#include <iostream>
#include <thread>
class DummyClass {
public:
    DummyClass()
    {}
    DummyClass(const DummyClass & obj)
    {}
    void sampleMemberFunction(int x)
    {
        std::cout<<"Inside sampleMemberFunction "<<x<<std::endl;
    }
};
int main() {
 
    DummyClass dummyObj;
    int x = 10;
    std::thread threadObj(&DummyClass::sampleMemberFunction,&dummyObj, x);
    threadObj.join();
    return 0;
}
```

输出如下：

```shell
Inside sampleMemberFunction 10
```

